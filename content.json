{"meta":{"title":"Nlll的博客","subtitle":"","description":"","author":"Nlll","url":"http://example.com"},"pages":[{"title":"404","date":"2024-02-25T11:37:57.225Z","updated":"2024-02-25T11:37:57.225Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":"这是一个404界面，放张玛玛的美图 (如果你看不见，这是正常的，我还没放)"},{"title":"flag","date":"2024-03-02T08:52:28.000Z","updated":"2024-03-02T08:55:53.282Z","comments":true,"path":"flag/index.html","permalink":"http://example.com/flag/index.html","excerpt":"","text":"恭喜你找到了flag{Nlll's blog}"},{"title":"about","date":"2024-02-25T11:01:45.000Z","updated":"2024-02-25T11:01:45.765Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"2024暑假训练","slug":"2024summer-plan","date":"2024-06-03T11:00:16.000Z","updated":"2024-06-03T12:04:03.354Z","comments":true,"path":"2024/06/03/2024summer-plan/","permalink":"http://example.com/2024/06/03/2024summer-plan/","excerpt":"","text":"2024暑假训练 0.前言 简单记录一下今年暑假训练的题目和内容。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"plan","slug":"plan","permalink":"http://example.com/tags/plan/"}],"keywords":[]},{"title":"2024陕西省赛游记","slug":"SNCPC2024-travels","date":"2024-06-03T10:57:20.000Z","updated":"2024-06-03T12:02:08.758Z","comments":true,"path":"2024/06/03/SNCPC2024-travels/","permalink":"http://example.com/2024/06/03/SNCPC2024-travels/","excerpt":"","text":"2024陕西省赛游记 虽然说是游记，但主要还是打太烂了记录一下。 还是先赞美一下西交的组织，除了键盘回车有点抽象外都很好，场地只能说受限于校区硬件了。 至于题目，除了难度分级有点抽象并且实在对不上脑电波(你跟我说K比E难?)以外，单论题目本身都挺好的，也没有什么大锅。 奖杯很好看，可惜被薄纱根本捧不了杯，希望有生之年能捧次杯吧(但还是更希望明年因为众所周知的原因打星)。 说一下这场的过程，热身赛还是挺顺利的，因为机子有点问题，签完三道题基本就结束了，然后找高中同学聊了一会天就开始正式赛了。 前期签到速度中规中矩吧，大家都差不多的样子，签完四题后，去听了队友C的思路发现不对，又发现被同校另一支队n+1后有点慌了，口胡了一个假做法就上机去写，现在看来这时候可能就为之后的崩盘埋下伏笔。 C写了半天挂了4发后终于改对，此时发现前面十几支队的过题数都一样就稍微冷静了一点。听队友讲完K后，否了队友的二分做法，转而口胡了一个实现十分麻烦的做法(赛后又仔细想了想发现做法还假了，只能说我不愧是本场最大战犯)，然后立马上机去写，并让队友看一下L的结论。 写了20分钟后，发现我的做法实在是太难实现，于是给另一个代码能力稍微好点的队友讲了一下想让他写，但他表示他也不会()，于是在机上卡了半天基本什么都没写，终于队友把L结论证出来了，赶紧写了一下后下机，让队友去写他的B。 随后感觉K只要花时间实现就行(事实证明，这是一个愚蠢的决定)，于是去开了其它题，队友看了一下E和J表示没什么思路，我则是去看了I之后又很快贡献了一个假做法，并且直到结束都没改对。 之后就是帮队友改了下B，上机写I的假做法，发现wa了之后看着I自闭，封榜后，队友终于会了K的正解，结果是被我否掉的二分，于是去写。我终于接受I的做法不对后，去继续看E，可惜完全没思路。 队友写K时又发生了一些迷惑的事情导致最后也没开出来，结束的同时终于把造的小数据给过了，可惜交不上去也不知道改对没有。 总结一下，作为本场最大战犯的我除了一堆罚时和假做法外几乎没有什么贡献，队友的表现也一般，整个上机时间感觉不超过3小时，有效时间更是感觉连两个半小时都没有，只能说再次刷新了我们队的下限。 主要说一下自己的问题吧，感觉还是有点浮躁了，前两场邀请赛的发挥都不错，好几道Mid的题目都是一眼切的，再加上赛前想要捧杯的压力，导致比赛的时候确实不够冷静，有一些地方跟队友讲完后就没有再去看了，导致即使两个人看过的做法还是假了。最后两个小时有点盲目自信，观察出了I的一些性质后就一直硬刚，思路也从正解的路上越偏越远，导致更有可能的E和K也没有细想。 至于队伍的问题还是三个人没什么配合，甚至这场有点1+1&lt;2了，很多时候跟队友沟通思路的时候很难让对方理解(或者是我理解不了对方)，最后就是大概是对的这种心态，实际上并没有起到验证的效果，这也使得这场假做法很多(虽然最大原因还是我太爱口胡导致的)。另一点就是三个人没有很好的代码手，唯一一个写代码还行的队友实现能力也算不上强，这点其实去年济南区域赛就有所体现，写代码+假做法+调试占用大量时间导致很多开出来的题都没机会写，感觉暑假还是得多写点题锻炼一下代码能力。除此之外，一个虽然几乎没有影响本场但确实存在的问题就是补题和舒适圈，这场的J的核心思路和我们赛前一天晚上VP的电科校赛的J几乎一模一样，但大家V完看了题解后，因为都不太了解于是似乎也没太当回事，至少对我自己来说，我确实有点太局限于之前OI时期比较熟悉的知识了，像字符串，计算几何以及其它一些套路的题很少去看，只能说还是得多扩充自己的知识面，对于不会的题一定要补。 最后恭喜一下报销n+2亚军成功夺冠，也希望我们明年区域赛不要再像这场一样这么抽象，发挥出实力。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"CS","slug":"CS","permalink":"http://example.com/tags/CS/"},{"name":"游记","slug":"游记","permalink":"http://example.com/tags/%E6%B8%B8%E8%AE%B0/"}],"keywords":[]},{"title":"NWERC2017","slug":"NWERC2017","date":"2024-03-18T14:34:13.000Z","updated":"2024-03-19T10:38:58.471Z","comments":true,"path":"2024/03/18/NWERC2017/","permalink":"http://example.com/2024/03/18/NWERC2017/","excerpt":"","text":"Northwestern European Regional Contest 2017 0.前言 写一下周赛的题解，这场打的感觉不太行。 比赛链接：NWERC 2017 1.题目 A.Ascending Photo 一道挺奇怪的dp 首先把原序列离散化，同时连续的一段相同的数合并为一个数，这些操作显然不影响答案。 我们转换一下问题，我们先把所有数之间都切一刀，考虑最多能选几个位置不切。 注意到对能不切的位置一定是和之间的位置，且对于所有相邻的和，最多只有一个能不切。 直接贪是不行的，例如对，如果我们选择之间不切那么之间就必须切，前后有影响，因此考虑dp(反悔贪心应该也能做，并且个人感觉这个限制并不强，可能有一些神奇的做法也能过，我回头再想想。) 我们设表示只考虑的数时，把第个数放最前面最多能少切几个位置。 枚举顺序即根据的大小，从大到小枚举每个数。 我们根据是否独特，即只有一个位置值为来分类讨论。 同时为了方便叙述，我们设代表所有的位置。 1.独特 如果，我们显然可以将和连在一起。 否则，和在序列中都不相邻，更不可能连在一起。 所以有 2.不独特 注意，这里与上面最大的区别是当独特时，我们只需要考虑是否可以与相连。 而不独特时，我们需要考虑把所有值为的数都放进序列并让在最前面后，序列中最后一个值为的数是否与一个相连。 当，即时，对于，如果有，我们就可以让这个与相连并放在其它值为的数的后面，这样相连的数加(再次提醒和之间最多只有一个相连，所以其它值为的数一定不和相连，这样就是最优。) 当时，因为还有其它值为的数存在，所以我们一定不能让和相连，否则其它值为的数无法插入和中间，这与为最前面的数矛盾，其它情况则与上面相同。 转移方程为 具体实现方案如下： 独特数很简单，随便写一个或改一下非独特的方法就行了。 我们主要考虑非独特时的转移。 注意到，我们每个值为的数在转移时中每一项只有时才会最多相差，那我们不妨记为只考虑的项的最大值，为只考虑的项的最大值，为只考虑的项的次大值。 转移时，如果发现并且则 否则 最后注意一下边界即可。 代码： 1test B.Boss Battle 签到题。 当时，显然答案为。 当时，我们每次选择一个地方炸时可以排除下一时刻BOSS在我们炸的位置，每次炸的位置相连的话，每回合就可以多排除一个位置，那么一共个回合就可以保证炸到BOSS。 代码： 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n=0; scanf(\"%d\",&amp;n); if(n&lt;=3){printf(\"1\");return 0;} printf(\"%d\",n-2); return 0;} D.Dunglish 模拟+一点点数学，读懂题意就能写。 显然，对原序列第i个单词，设其总翻译数为，正确翻译数为 那么总翻译方案数为，正确翻译方案数为，错误翻译方案数即两个相减。 用map就可以存下 代码实现的比较乱，回头有时间改改。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;string s[25],x,y,z;map&lt;string,ll&gt; M1,M2,ppd;map&lt;string,string&gt; M;int main(){ int n=0,m=0,pd=0;ll ans1=1,ans2=0,zc=1; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s[i]; } scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;i++) { cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; if(z[0]=='c') { M1[x]++; } else { M2[x]++; ppd[x]=1; } M[x]=y; } for(int i=1;i&lt;=n;i++) { ans1=ans1*M1[s[i]]; zc=zc*(M1[s[i]]+M2[s[i]]); } ans2=zc-ans1; if(zc==1) { for(int i=1;i&lt;=n;i++) { cout&lt;&lt;M[s[i]]&lt;&lt;\" \"; if(ppd[s[i]]==1){pd=1;} } putchar('\\n'); if(pd) { printf(\"incorrect\\n\"); } else { printf(\"correct\\n\"); } } else { printf(\"%lld correct\\n\",ans1); printf(\"%lld incorrect\\n\",ans2); } return 0;} F.Factor-Free Tree 回头补() 代码： 1test G.Glyph Recognition 计算几何。 直接按题意枚举即可，最小边长可以二分查找，也可以手推，但手推估计比较痛苦。 个人感觉不太好实现，回头看看别人怎么写得。 代码： 1test I.Installing Apps dp+贪心 首先转换成堆箱子的问题(每个箱子有自重和最大承重，问能否从上到下堆在一起)。 对下载大小为，储存大小为的软件，等价于自重为，最大承重为的箱子。 直接由箱子的结论得到，如果存在合法方案，我们一定可以把方案中的箱子按自重加最大承重从小到大的排序顺序从上往下堆。 再看原问题，即按从小到大排序，然后按序找安装哪些软件。 显然，我们可以用01背包解决。 注意，这里我们的状态可以不设成表示前i个软件占大小为j的最大个数，而是，表示前i个软件安装j个的最小内存，这样更好实现并且时间复杂度更低。 最后给一下箱子结论的证明： 我们设表示自重，表示承重，第个箱子为最上面的，第个箱子为最下面的。 假设一种合法方案中，存在，有，那么我们将和交换位置。 则交换后合法的条件为 即： 由原方案合法得： 所以： 该结论得证。(还有个小结论是如果存在合法方案，这样排序可以使最小的承重减负重的值最大) 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;struct node{ int d;int s;int nu; bool operator &lt; (const node &amp;x)const { return (s-d)&lt;x.s-x.d; }};node a[505];int f[505][505],pre[505][505];int Ans[505],cnt;int main(){ int n=0,c=0,ans=0,z=0; scanf(\"%d%d\",&amp;n,&amp;c); for(int i=1;i&lt;=n;i++) { scanf(\"%d%d\",&amp;a[i].d,&amp;a[i].s); a[i].nu=i; } sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { f[i][j]=1e9; } } f[0][0]=0; for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;i;j++) { if(f[i][j]&gt;f[i-1][j]) { f[i][j]=f[i-1][j]; pre[i][j]=0; } if(f[i][j+1]&gt;f[i-1][j]+a[i].s&amp;&amp;c-f[i-1][j]&gt;=a[i].d) { f[i][j+1]=f[i-1][j]+a[i].s; pre[i][j+1]=i; } } } for(int j=n;j&gt;=0;j--) { if(f[n][j]&lt;=c) { z=j; break; } } printf(\"%d\\n\",z); while(z) { if(!pre[n][z]) { n--; } else { cnt++;Ans[cnt]=a[n].nu; z--;n--; } } for(int i=cnt;i;i--) { printf(\"%d \",Ans[i]); } return 0;} J.Juggling Troupe 最有意思的一道。 我们先考虑只有个的情况，假设所在的位置为，左边最近的的位置为(如果没有则)，右边最近的的位置为(如果没有则)。 如果写个暴力观察一下就会发现转移过程很有规律，结果为变成，变成，变成，如果，那么变成 PS:如果或实际上就是球扔到台下，但我们可以认为球仍在或，并且这两个位置的球不会移动。 我们可以由不变量给出一个不太严谨的证明： 首先，设表示第个位置球的数量， 那么易证，和在整个过程中是守恒的。 我们只考虑L到R的区域(这一步其实不严谨，可以证明一定只有到间会发生转移，但有点麻烦) 既然如此，只有一个的情况下，最后，原本的个数为，则由守恒得到最后应该只有个，其余位置都为 那么设为的位置为，由守恒得： 然后就是本题重点，如何证明球转移的顺序是无关的。 这个结论还是挺好猜的，但不一定敢写。 证明如下： 我们认为第个位置向两边扔球为对进行一次操作，那我们会有一个初始的可操作集合。 注意到对操作后，只会让的可操作次数减，两边位置的可操作次数可能加(或者说加，其实就是) 那么不论我们的操作的顺序如何，每个数被操作的次数其实是不会因此改变的，结果自然也相同。 所以，我们只需对每个单独考虑就行。 实现就用set维护的位置和每个对应的和，注意一个细节就是如果的位置是另一个，我们应该把它改成而不是 PS：这道题证明顺序无关的方法感觉挺容易推广到其它问题上的。 大概可以这样表述： 对某一元素操作不会使其它元素的操作次数减少，只会按一个关于该操作为对该元素第几次操作的规则影响其它元素的操作次数(只可能使其它元素操作次数增加，不会造成其它影响)，那么操作顺序无关。 这里贴一下相关的几道题。 Codeforces Global Round 10 F.Omkar and Landslide Hot Dog Proliferation (Large) 还有一个叫《十步万度》的游戏，里面操作的可交换性也可以这么证。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define It set&lt;int&gt;::iteratorusing namespace std;const int Maxn=1e6+5;char c[Maxn];int a[Maxn];set&lt;int&gt; s;int main(){ int n=0,L=0,R=0,x=0;It itl,itr; scanf(\"%s\",c+1); n=strlen(c+1); s.insert(0);s.insert(n+1); for(int i=1;i&lt;=n;i++) { a[i]=c[i]-'0'; if(!a[i]){s.insert(i);} } for(int i=1;i&lt;=n;i++) { if(a[i]!=2){continue;} itl=s.lower_bound(i); itr=itl;itl--;R=*itr;L=*itl; if(L){a[L]=1;s.erase(itl);} if(R!=n+1){a[R]=1;s.erase(itr);} a[i]=1;x=L+R-i;a[x]--; if(!a[x]){s.insert(x);} } for(int i=1;i&lt;=n;i++) { printf(\"%d\",a[i]); } return 0;}","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"CS","slug":"CS","permalink":"http://example.com/tags/CS/"},{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"}],"keywords":[]},{"title":"Matula","slug":"Matula","date":"2024-03-12T16:19:27.000Z","updated":"2024-03-12T16:19:27.722Z","comments":true,"path":"2024/03/13/Matula/","permalink":"http://example.com/2024/03/13/Matula/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"更新计划","slug":"plan","date":"2024-03-02T04:15:25.000Z","updated":"2024-03-02T09:10:25.144Z","comments":true,"path":"2024/03/02/plan/","permalink":"http://example.com/2024/03/02/plan/","excerpt":"","text":"更新计划 暂定的该博客的更新计划。 1.评论系统 目前在考虑用Twikoo还是Waline，不清楚Twikoo的安全性怎么样。 (你真觉得这个博客会有人看吗) 2.置顶显示 把置顶的tag变成自动添加的。 3.个性化域名 如题。 4.彩蛋 虽然这个博客大概没什么人看就是了。","categories":[],"tags":[{"name":"置顶","slug":"置顶","permalink":"http://example.com/tags/%E7%BD%AE%E9%A1%B6/"}],"keywords":[]},{"title":"GEB读书笔记","slug":"GEB","date":"2024-03-01T13:52:16.000Z","updated":"2024-03-01T13:57:17.755Z","comments":true,"path":"2024/03/01/GEB/","permalink":"http://example.com/2024/03/01/GEB/","excerpt":"","text":"开个大坑，准备读GEB的英文原著，这篇博客用来记录读书笔记和想法，先占个位。 希望半年内能读完吧。","categories":[],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}],"keywords":[]},{"title":"射影几何0","slug":"projective-geometry0","date":"2024-02-28T06:21:40.000Z","updated":"2024-03-02T08:21:31.094Z","comments":true,"path":"2024/02/28/projective-geometry0/","permalink":"http://example.com/2024/02/28/projective-geometry0/","excerpt":"","text":"准备有时间学一下射影几何，先占个坑。","categories":[],"tags":[],"keywords":[]},{"title":"浅谈约瑟夫环问题","slug":"josephus-problem","date":"2024-02-25T09:23:36.000Z","updated":"2024-03-03T06:51:54.245Z","comments":true,"path":"2024/02/25/josephus-problem/","permalink":"http://example.com/2024/02/25/josephus-problem/","excerpt":"","text":"浅谈约瑟夫环问题 Update:寄，写完了突然发现和oi-wiki上的几乎一模一样，脑回路神奇地重合了。 不过一些地方理解方式有些区别，只能说还是有点意义的。 0.前言 近日洛谷上看到了这道题P8671 [蓝桥杯 2018 国 AC] 约瑟夫环，发现自己对约瑟夫环的一些写法不太了解，所以记录一下。 1.问题叙述 本文讨论的约瑟夫环问题表述如下： 个人，从开始报数，数到的人淘汰，然后重新从报数，问最后一人的编号，为了讲述方便，我们规定编号从开始。 2.通用解法 2.1 暴力枚举 我们用链表储存现有的人，然后暴力枚举。这样做删除的复杂度为，寻找下一个人的复杂度为 (还有一种实现，对每个元素记录它之前和之后第个元素的编号，每删除一个元素后，对它前k个元素进行修改，删除的复杂度，但个人觉得实现比较复杂) 时间复杂度： 2.2 数据结构优化 注意到2.1的瓶颈在于寻找下一个被淘汰的人，我们考虑用数据结构优化。 我们改用数组存储每个人是否被淘汰，然后用线段树二分在的时间内寻找下一个元素。 时间复杂度： 另外，我们也可以用跳表等维护。 2.3 递推 这算是一个重点了，我们设表示个人，数到淘汰的前提下，最后剩下的人的编号，且编号从开始。 显然，我们考虑从个人开始添加人会使最后的幸存者的编号发生什么变化。 即已知，求 显然，个人开始游戏后，第一个被淘汰的人的编号为，我们会从编号的人开始报数，且此时只有个人，我们把这个人当作新的，那答案显然为，再将新编号换为原本的编号，我们就有 线性递推地做即可。 时间复杂度： 2.4 递推优化 观察2.3的式子，我们实际上没有必要在每次加上后都进行取模。只有当时，我们才需要减去，并且有 考虑只在需要取模时转移，设当前已求出人数为的情况，下一个需要取模的人数为，则 即 即 算出后，可以由 得到，然后将作为新的 按如上方式转移，直到对于当前求出的，然后得到 从而求出答案，注意时需要特判。 时间复杂度：的增长率大约为，因此使大于等于的时间复杂度约为 我们设 则 画图后观察到收敛很快，因此我们可以将近似为一条直线，斜率为在趋于正无穷时的极限，易得 由上述得， 时间复杂度为 当时上式较为准确，与大小相近时会有较大偏差。 3.一些其它结论 3.1 时的答案 当时，我们可以通过另一种方法得到答案。 假设，我们易得(每次所有人数过一遍后，剩下的人数仍为的幂) 所以当总人数为2的幂时，从谁开始，则谁为最后剩下的人。 那考虑一般情况 当淘汰了个人时，我们有 所以此时我们会从编号为的人开始，且只剩下个人，最后剩下的编号即为 所以对，有 3.2 对时答案的探索 4.推广问题 约瑟夫问题还可以进行一些推广。 比如每次淘汰数最后个数的人，求最后剩下的个人的编号。 等之后我有想法了再来补充。","categories":[{"name":"CS","slug":"CS","permalink":"http://example.com/categories/CS/"},{"name":"ACM","slug":"CS/ACM","permalink":"http://example.com/categories/CS/ACM/"},{"name":"数学","slug":"CS/ACM/数学","permalink":"http://example.com/categories/CS/ACM/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"CS","slug":"CS","permalink":"http://example.com/tags/CS/"},{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}],"keywords":[{"name":"CS","slug":"CS","permalink":"http://example.com/categories/CS/"},{"name":"ACM","slug":"CS/ACM","permalink":"http://example.com/categories/CS/ACM/"},{"name":"数学","slug":"CS/ACM/数学","permalink":"http://example.com/categories/CS/ACM/%E6%95%B0%E5%AD%A6/"}]}]}