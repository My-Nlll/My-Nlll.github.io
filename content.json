{"meta":{"title":"Nlll的博客","subtitle":"","description":"","author":"Nlll","url":"http://example.com"},"pages":[{"title":"about","date":"2024-02-25T11:01:45.000Z","updated":"2024-02-25T11:01:45.765Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"404","date":"2024-02-25T11:37:57.225Z","updated":"2024-02-25T11:37:57.225Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":"这是一个404界面，放张玛玛的美图 (如果你看不见，这是正常的，我还没放)"}],"posts":[{"title":"浅谈约瑟夫环问题","slug":"josephus-problem","date":"2024-02-25T09:23:36.000Z","updated":"2024-02-25T12:17:40.211Z","comments":true,"path":"2024/02/25/josephus-problem/","permalink":"http://example.com/2024/02/25/josephus-problem/","excerpt":"","text":"浅谈约瑟夫环问题 Update:寄，写完了突然发现和oi-wiki上的几乎一模一样，脑回路神奇地重合了。 不过一些地方理解方式有些区别，只能说还是有点意义的。 0.前言 近日洛谷上看到了这道题P8671 [蓝桥杯 2018 国 AC] 约瑟夫环，发现自己对约瑟夫环的一些写法不太了解，所以记录一下。 1.问题叙述 本文讨论的约瑟夫环问题表述如下： \\(n\\)个人，从\\(1\\)开始报数，数到\\(k\\)的人淘汰，然后重新从\\(1\\)报数，问最后一人的编号，为了讲述方便，我们规定编号从\\(0\\)开始。 2.通用解法 2.1 暴力枚举 我们用链表储存现有的人，然后暴力枚举。这样做删除的复杂度为\\(O(1)\\)，寻找下一个人的复杂度为\\(O(k)\\) (还有一种实现，对每个元素记录它之前和之后第\\(m\\)个元素的编号，每删除一个元素后，对它前m个元素进行修改，删除的复杂度\\(O(m)\\)，但个人觉得实现比较复杂) 时间复杂度：\\(O(nk)\\) 2.2 数据结构优化 注意到2.1的瓶颈在于寻找下一个被淘汰的人，我们考虑用数据结构优化。 我们改用数组存储每个人是否被淘汰，然后用线段树二分在\\(O(\\log n)\\)的时间内寻找下一个元素。 时间复杂度：\\(O(n\\log n)\\) 另外，我们也可以用跳表等维护，时间复杂度自己算吧。 2.3 递推 这算是一个重点了，我们设\\(F_k(x)\\)表示\\(x\\)个人，数到\\(k\\)淘汰的前提下，最后剩下的人的编号，且编号从\\(0\\)开始。 显然\\(F_k(1)=0\\)，我们考虑从\\(1\\)个人开始添加人会使最后的幸存者的编号发生什么变化。 即已知\\(F_k(n-1)\\)，求\\(F_K(n)\\) 显然，\\(n\\)个人开始游戏后，第一个被淘汰的人的编号为\\(k-1 \\mod i\\)，我们会从编号\\(k \\mod n\\)的人开始报数，且此时只有\\(n-1\\)个人，我们把这个人当作新的\\(0\\)，那答案显然为\\(F_k(n-1)\\)，再将新编号换为原本的编号，我们就有 \\[F_k(n)=(F_k(n-1)+k) \\mod n\\] 线性递推地做即可。 时间复杂度：\\(O(n)\\) 2.4 递推优化 观察2.3的式子，我们实际上没有必要在每次加上\\(k\\)后都进行取模。只有当\\(F_k(n-1)+k \\geq n\\)时，我们才需要减去\\(n\\)，并且有\\(F_k(n) &lt; k\\) 考虑只在需要取模时转移，设当前已求出人数为\\(x\\)的情况，下一个需要取模的人数为\\(y\\)，则 \\[ \\begin{cases} F_k(x)+(y-x)k \\geq y \\\\ F_k(x)+(y-x-1)k &lt; y-1 \\\\ \\end{cases} \\] 即 \\[\\lceil \\frac{kx-F_k(x)}{k-1} \\rceil \\leq y &lt; \\frac{kx+k-1-F_k(x)}{k-1} = \\frac{kx-F_k(x)}{k-1}+1\\] 即 \\[y=\\lceil \\frac{kx-F_k(x)}{k-1} \\rceil\\] 算出\\(y\\)后，可以由 \\(F_k(y)=(F_k(x)+(y-x)k) \\mod y\\) 得到\\(F_k(y)\\)，然后将\\(y\\)作为新的\\(x\\) 按如上方式转移，直到对于当前\\(x\\)求出的\\(y \\geq n\\)，然后得到 \\[F_k(n)=(F_k(x)+(n-x)k) \\mod n\\] 从而求出答案，注意\\(k=1\\)时需要特判。 时间复杂度：\\(y\\)的增长率大约为\\(\\frac{k}{k-1}\\)，因此使\\(y\\)大于等于\\(n\\)的时间复杂度约为\\(O(\\log_{\\frac{k}{k-1}} n)\\) 我们设\\(f(x)=\\log_{\\frac{x}{x-1}} n\\) 则 \\[\\begin{aligned} f&#39;(x)&amp;=\\frac{1}{x\\left(x-1\\right)\\ln\\left(\\frac{x}{x-1}\\right)\\log_{n}\\left(\\frac{x}{x-1}\\right)} \\\\ &amp;=\\frac{\\ln n}{x\\left(x-1\\right)\\ln^{2}\\left(1+\\frac{1}{x-1}\\right)} \\end{aligned}\\] 画图后观察到\\(f&#39;(x)\\)收敛很快，因此我们可以将\\(f(x)\\)近似为一条直线，斜率为\\(f(x)\\)在\\(x\\)趋于正无穷时的极限，易得 \\[\\begin{aligned} \\lim_{x \\to \\infty}f&#39;(x)&amp;=\\lim_{x \\to \\infty}\\frac{\\ln n}{x\\left(x-1\\right)\\ln^{2}\\left(1+\\frac{1}{x-1}\\right)} \\\\ &amp;=\\lim_{x \\to \\infty}\\frac{\\ln n}{\\left(\\ln\\left(\\left(1+\\frac{1}{x-1}\\right)^{x-1}\\right)\\right)\\left(\\ln\\left(\\left(1+\\frac{1}{x-1}\\right)^{x-1}\\right)+\\ln\\left(1+\\frac{1}{x-1}\\right)\\right)} \\\\ &amp;=\\ln n \\end{aligned}\\] 由上述得，\\(f(x) \\approx x\\ln n\\) 时间复杂度为\\(O(f(k)) \\approx O(k\\ln n)\\) 当\\(n \\gg k\\)时上式较为准确，\\(n\\)与\\(k\\)大小相近时会有较大偏差。 3.一些其它结论 3.1 \\(k=2\\)时的答案 当\\(k=2\\)时，我们可以通过另一种方法得到答案。 假设\\(n=2^c\\)，我们易得\\(F_2(n)=F_2(2^c)=0\\)(每次所有人数过一遍后，剩下的人数仍为\\(2\\)的幂) 所以当总人数为2的幂时，从谁开始，则谁为最后剩下的人。 那考虑一般情况\\(n=2^c+r,r &lt; 2^c\\) 当淘汰了\\(r\\)个人时，我们有 \\[2r &lt; 2^c+r &lt; n\\] 所以此时我们会从编号为\\(2r\\)的人开始，且只剩下\\(2^c\\)个人，最后剩下的编号即为\\(2r\\) 所以对\\(n=2^c+r,r &lt; 2^c\\)，有\\(F_2(n)=2r\\) 3.2 对\\(k=3\\)时答案的探索 4.推广问题 约瑟夫问题还可以进行一些推广。 比如每次淘汰数最后\\(z\\)个数的人，求最后剩下的\\(z\\)个人的编号。 等之后我有想法了再来补充。","categories":[{"name":"CS","slug":"CS","permalink":"http://example.com/categories/CS/"},{"name":"ACM","slug":"CS/ACM","permalink":"http://example.com/categories/CS/ACM/"},{"name":"数学","slug":"CS/ACM/数学","permalink":"http://example.com/categories/CS/ACM/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"},{"name":"CS","slug":"CS","permalink":"http://example.com/tags/CS/"},{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}],"keywords":[{"name":"CS","slug":"CS","permalink":"http://example.com/categories/CS/"},{"name":"ACM","slug":"CS/ACM","permalink":"http://example.com/categories/CS/ACM/"},{"name":"数学","slug":"CS/ACM/数学","permalink":"http://example.com/categories/CS/ACM/%E6%95%B0%E5%AD%A6/"}]},{"title":"my-first-blog","slug":"my-first-blog","date":"2024-02-16T09:50:51.000Z","updated":"2024-02-16T09:51:53.753Z","comments":true,"path":"2024/02/16/my-first-blog/","permalink":"http://example.com/2024/02/16/my-first-blog/","excerpt":"","text":"test","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2024-02-16T09:21:42.135Z","updated":"2024-02-16T09:21:42.135Z","comments":true,"path":"2024/02/16/hello-world/","permalink":"http://example.com/2024/02/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}