{"meta":{"title":"Nlll的博客","subtitle":"","description":"","author":"Nlll","url":"http://example.com"},"pages":[{"title":"404","date":"2024-02-25T11:37:57.225Z","updated":"2024-02-25T11:37:57.225Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":"这是一个404界面，放张玛玛的美图 (如果你看不见，这是正常的，我还没放)"},{"title":"flag","date":"2024-03-02T08:52:28.000Z","updated":"2024-03-02T08:55:53.282Z","comments":true,"path":"flag/index.html","permalink":"http://example.com/flag/index.html","excerpt":"","text":"恭喜你找到了flag{Nlll's blog}"},{"title":"about","date":"2024-02-25T11:01:45.000Z","updated":"2024-02-25T11:01:45.765Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"NWERC2017","slug":"NWERC2017","date":"2024-03-18T14:34:13.000Z","updated":"2024-03-18T17:33:37.894Z","comments":true,"path":"2024/03/18/NWERC2017/","permalink":"http://example.com/2024/03/18/NWERC2017/","excerpt":"","text":"Northwestern European Regional Contest 2017 0.前言 写一下周赛的题解，这场打的感觉不太行。 比赛链接：NWERC 2017 1.题目 A.Ascending Photo 一道挺奇怪的dp 首先把原序列离散化，同时连续的一段相同的数合并为一个数，这些操作显然不影响答案。 我们转换一下问题，我们先把所有数之间都切一刀，考虑最多能选几个位置不切。 注意到对能不切的位置一定是\\(x\\)和\\(x+1\\)之间的位置，且对于所有相邻的\\(x\\)和\\(x+1\\)，最多只有一个能不切。 直接贪是不行的，例如对\\([x-1,x,x+1]\\)，如果我们选择之间不切那么之间就必须切，前后有影响，因此考虑dp(反悔贪心应该也能做，并且个人感觉这个限制并不强，可能有一些神奇的做法也能过，我回头再想想。) 我们设\\(f_x\\)表示只考虑\\(h_i \\geq h_x\\)的数时，把第\\(x\\)个数放最前面最多能少切几个位置。 枚举顺序即根据\\(h_i\\)的大小，从大到小枚举每个数。 我们根据\\(h_x\\)是否独特，即只有一个位置值为\\(h_x\\)来分类讨论。 同时为了方便叙述，我们设\\(y\\)代表所有\\(h_y=h_x+1\\)的位置。 1.\\(h_x\\)独特 如果\\(y=x+1\\)，我们显然可以将\\(x\\)和\\(y\\)连在一起。 否则，\\(x\\)和\\(y\\)在序列中都不相邻，更不可能连在一起。 所以有 \\[ f_x=\\max_{h_y=h_x+1} \\{ f_y + [y=x+1] \\} \\] 2.\\(h_x\\)不独特 注意，这里与上面最大的区别是当\\(h_x\\)独特时，我们只需要考虑\\(x\\)是否可以与\\(y\\)相连。 而\\(h_x\\)不独特时，我们需要考虑把所有值为\\(h_x\\)的数都放进序列并让\\(x\\)在最前面后，序列中最后一个值为\\(h_x\\)的数\\(z\\)是否与一个\\(y\\)相连。 当\\(h_{x+1} \\neq h_x + 1=h_y\\)，即\\(\\forall y,y \\neq x+1\\)时，对于\\(\\forall y\\)，如果有\\(h_{y-1}=h_x\\)，我们就可以让这个\\(y\\)与\\(y-1\\)相连并放在其它值为\\(h_x\\)的数的后面，这样相连的数加\\(1\\)(再次提醒\\(x\\)和\\(y\\)之间最多只有一个相连，所以其它值为\\(h_x\\)的数一定不和\\(y\\)相连，这样就是最优。) 当\\(h_{x+1} = h_x + 1\\)时，因为还有其它值为\\(h_x\\)的数存在，所以我们一定不能让\\(x\\)和\\(x+1\\)相连，否则其它值为\\(h_x\\)的数无法插入\\(x\\)和\\(x+1\\)中间，这与\\(x\\)为最前面的数矛盾，其它情况则与上面相同。 转移方程为 \\[ f_x=\\max_{h_y=h_x+1} \\{ f_y + [h_{y-1}=h_x \\wedge y \\neq x+1] \\} \\] 具体实现方案如下： 独特数很简单，随便写一个或改一下非独特的方法就行了。 我们主要考虑非独特时的转移。 注意到，我们每个值为\\(h_x\\)的数在转移时\\(\\max\\)中每一项只有\\(h_{y-1}=h_x\\)时才会最多相差\\(1\\)，那我们不妨记\\(Max\\)为只考虑\\(h_{y-1} \\neq h_x\\)的项的最大值，\\(Max_1\\)为只考虑\\(h_{y-1} = h_x\\)的项的最大值，\\(Max_2\\)为只考虑\\(h_{y-1} = h_x\\)的项的次大值。 转移时，如果发现\\(h_{x+1}=h_x+1\\)并且\\(f_{x+1} + 1 = Max_1\\)则 \\[ f_x=\\max \\{ Max,Max_1-1,Max_2 \\} \\] 否则 \\[ f_x=\\max \\{ Max,Max_1,Max_2 \\} \\] 最后注意一下边界即可。 代码： 1test B.Boss Battle 签到题。 当\\(n \\leq 3\\)时，显然答案为\\(1\\)。 当\\(n &gt; 3\\)时，我们每次选择一个地方炸时可以排除下一时刻BOSS在我们炸的位置，每次炸的位置相连的话，每回合就可以多排除一个位置，那么一共\\(n-2\\)个回合就可以保证炸到BOSS。 代码： 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n=0; scanf(\"%d\",&amp;n); if(n&lt;=3){printf(\"1\");return 0;} printf(\"%d\",n-2); return 0;} D.Dunglish 模拟+一点点数学，读懂题意就能写。 显然，对原序列第i个单词\\(s_i\\)，设其总翻译数为\\(p_i\\)，正确翻译数为\\(q_i\\) 那么总翻译方案数为\\(\\prod_{i=1}^n p_i\\)，正确翻译方案数为\\(\\prod_{i=1}^n q_i\\)，错误翻译方案数即两个相减。 用map就可以存下\\(p_i,q_i\\) 代码实现的比较乱，回头有时间改改。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;string s[25],x,y,z;map&lt;string,ll&gt; M1,M2,ppd;map&lt;string,string&gt; M;int main(){ int n=0,m=0,pd=0;ll ans1=1,ans2=0,zc=1; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s[i]; } scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;i++) { cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; if(z[0]=='c') { M1[x]++; } else { M2[x]++; ppd[x]=1; } M[x]=y; } for(int i=1;i&lt;=n;i++) { ans1=ans1*M1[s[i]]; zc=zc*(M1[s[i]]+M2[s[i]]); } ans2=zc-ans1; if(zc==1) { for(int i=1;i&lt;=n;i++) { cout&lt;&lt;M[s[i]]&lt;&lt;\" \"; if(ppd[s[i]]==1){pd=1;} } putchar('\\n'); if(pd) { printf(\"incorrect\\n\"); } else { printf(\"correct\\n\"); } } else { printf(\"%lld correct\\n\",ans1); printf(\"%lld incorrect\\n\",ans2); } return 0;} F.Factor-Free Tree 回头补() 代码： 1test G.Glyph Recognition 计算几何。 直接按题意枚举即可，最小边长可以二分查找，也可以手推，但手推估计比较痛苦。 个人感觉不太好实现，回头看看别人怎么写得。 代码： 1test I.Installing Apps dp+贪心 首先转换成堆箱子的问题(每个箱子有自重和最大承重，问能否从上到下堆在一起)。 对下载大小为\\(d_i\\)，储存大小为\\(s_i\\)的软件，等价于自重为\\(s_i\\)，最大承重为\\(c-d_i\\)的箱子。 直接由箱子的结论得到，如果存在合法方案，我们一定可以把方案中的箱子按自重加最大承重从小到大的排序顺序从上往下堆。 再看原问题，即按\\(s_i-d_i\\)从小到大排序，然后按序找安装哪些软件。 显然，我们可以用01背包解决。 注意，这里我们的状态可以不设成\\(f_{i,j}\\)表示前i个软件占大小为j的最大个数，而是\\(f_{i，j}\\)表示前i个软件安装j个的最小内存，这样更好实现并且时间复杂度更低。 最后给一下箱子结论的证明： 我们设\\(a_i\\)表示自重，\\(b_i\\)表示承重，第\\(1\\)个箱子为最上面的，第\\(n\\)个箱子为最下面的。 假设一种合法方案中，存在\\(i&lt;j\\)，有\\(a_i + b_i &gt; a_j + b_j\\)，那么我们将\\(i\\)和\\(j\\)交换位置。 则交换后合法的条件为\\(b_j \\geq \\sum_{k=1}^{i-1} a_k,b_i \\geq -a_i + \\sum_{k=1}^{j} a_k\\) 即：\\(b_j \\geq \\sum_{k=1}^{i-1} a_k,a_i + b_i \\geq \\sum_{k=1}^{j} a_k\\) 由原方案合法得：\\(b_i \\geq \\sum_{k=1}^{i-1} a_i,b_j \\geq \\sum_{k=1}^{j-1} a_k\\) 所以：\\(b_j \\geq \\sum_{k=1}^{j-1} a_k \\geq \\sum_{k=1}^{i-1} a_k,a_i + b_i &gt; a_j + b_j \\geq \\sum_{k=1}^{j} a_k\\) 该结论得证。(还有个小结论是如果存在合法方案，这样排序可以使最小的承重减负重的值最大) 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;struct node{ int d;int s;int nu; bool operator &lt; (const node &amp;x)const { return (s-d)&lt;x.s-x.d; }};node a[505];int f[505][505],pre[505][505];int Ans[505],cnt;int main(){ int n=0,c=0,ans=0,z=0; scanf(\"%d%d\",&amp;n,&amp;c); for(int i=1;i&lt;=n;i++) { scanf(\"%d%d\",&amp;a[i].d,&amp;a[i].s); a[i].nu=i; } sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { f[i][j]=1e9; } } f[0][0]=0; for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;i;j++) { if(f[i][j]&gt;f[i-1][j]) { f[i][j]=f[i-1][j]; pre[i][j]=0; } if(f[i][j+1]&gt;f[i-1][j]+a[i].s&amp;&amp;c-f[i-1][j]&gt;=a[i].d) { f[i][j+1]=f[i-1][j]+a[i].s; pre[i][j+1]=i; } } } for(int j=n;j&gt;=0;j--) { if(f[n][j]&lt;=c) { z=j; break; } } printf(\"%d\\n\",z); while(z) { if(!pre[n][z]) { n--; } else { cnt++;Ans[cnt]=a[n].nu; z--;n--; } } for(int i=cnt;i;i--) { printf(\"%d \",Ans[i]); } return 0;} J.Juggling Troupe 最有意思的一道。 我们先考虑只有\\(1\\)个\\(2\\)的情况，假设\\(2\\)所在的位置为\\(P\\)，\\(P\\)左边最近的\\(0\\)的位置为\\(L\\)(如果没有则\\(L=0\\))，\\(P\\)右边最近的\\(0\\)的位置为\\(R\\)(如果没有则\\(R=n+1\\))。 如果写个暴力观察一下就会发现转移过程很有规律，结果为\\(L\\)变成\\(1\\)，\\(R\\)变成\\(1\\)，\\(L+R-P\\)变成\\(0\\)，如果\\(P \\neq L+R-P\\)，那么\\(P\\)变成\\(1\\) PS:如果\\(L=0\\)或\\(R=n+1\\)实际上就是球扔到台下，但我们可以认为球仍在\\(0\\)或\\(n+1\\)，并且这两个位置的球不会移动。 我们可以由不变量给出一个不太严谨的证明： 首先，设\\(p_i\\)表示第\\(i\\)个位置球的数量，\\(q_i=p_i \\cdot i\\) 那么易证，\\(\\sum p_i\\)和\\(\\sum q_i\\)在整个过程中是守恒的。 我们只考虑L到R的区域(这一步其实不严谨，可以证明一定只有\\(L\\)到\\(R\\)间会发生转移，但有点麻烦) 既然如此，只有一个\\(2\\)的情况下，最后\\(\\forall i,p_i \\leq 1\\)，原本\\(0\\)的个数为\\(2\\)，则由\\(\\sum p_i\\)守恒得到最后应该只有\\(1\\)个\\(0\\)，其余位置都为\\(1\\) 那么设为\\(0\\)的位置为\\(x\\)，由\\(\\sum q_i\\)守恒得：\\(\\sum_{i=L}^{R} i - x = \\sum_{i=L+1}^{R-1} i + P \\Rightarrow x = L + R - P\\) 然后就是本题重点，如何证明球转移的顺序是无关的。 这个结论还是挺好猜的，但不一定敢写。 证明如下： 我们认为第\\(i\\)个位置向两边扔球为对\\(i\\)进行一次操作，那我们会有一个初始的可操作集合。 注意到对\\(i\\)操作后，只会让\\(i\\)的可操作次数减\\(1\\)，\\(i\\)两边位置的可操作次数可能加\\(1\\)(或者说加\\(0.5\\)，其实就是\\(p_i \\leftarrow p_i - 2,p_{i-1} \\leftarrow p_{i-1} + 1,p_{i+1} \\leftarrow p_{i+1} + 1\\)) 那么不论我们的操作的顺序如何，每个数被操作的次数其实是不会因此改变的，结果自然也相同。 所以，我们只需对每个\\(2\\)单独考虑就行。 实现就用set维护\\(0\\)的位置和每个\\(2\\)对应的\\(L\\)和\\(R\\)，注意一个细节就是如果\\(L+R-P\\)的位置是另一个\\(2\\)，我们应该把它改成\\(1\\)而不是\\(0\\) PS：这道题证明顺序无关的方法感觉挺容易推广到其它问题上的，这里贴一下相关的几道题。 Codeforces Global Round 10 F.Omkar and Landslide Hot Dog Proliferation (Large) 还有一个叫《十步万度》的游戏，里面操作的可交换性也可以这么证。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define It set&lt;int&gt;::iteratorusing namespace std;const int Maxn=1e6+5;char c[Maxn];int a[Maxn];set&lt;int&gt; s;int main(){ int n=0,L=0,R=0,x=0;It itl,itr; scanf(\"%s\",c+1); n=strlen(c+1); s.insert(0);s.insert(n+1); for(int i=1;i&lt;=n;i++) { a[i]=c[i]-'0'; if(!a[i]){s.insert(i);} } for(int i=1;i&lt;=n;i++) { if(a[i]!=2){continue;} itl=s.lower_bound(i); itr=itl;itl--;R=*itr;L=*itl; if(L){a[L]=1;s.erase(itl);} if(R!=n+1){a[R]=1;s.erase(itr);} a[i]=1;x=L+R-i;a[x]--; if(!a[x]){s.insert(x);} } for(int i=1;i&lt;=n;i++) { printf(\"%d\",a[i]); } return 0;}","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"CS","slug":"CS","permalink":"http://example.com/tags/CS/"},{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"}],"keywords":[]},{"title":"Matula","slug":"Matula","date":"2024-03-12T16:19:27.000Z","updated":"2024-03-12T16:19:27.722Z","comments":true,"path":"2024/03/13/Matula/","permalink":"http://example.com/2024/03/13/Matula/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"更新计划","slug":"plan","date":"2024-03-02T04:15:25.000Z","updated":"2024-03-02T09:10:25.144Z","comments":true,"path":"2024/03/02/plan/","permalink":"http://example.com/2024/03/02/plan/","excerpt":"","text":"更新计划 暂定的该博客的更新计划。 1.评论系统 目前在考虑用Twikoo还是Waline，不清楚Twikoo的安全性怎么样。 (你真觉得这个博客会有人看吗) 2.置顶显示 把置顶的tag变成自动添加的。 3.个性化域名 如题。 4.彩蛋 虽然这个博客大概没什么人看就是了。","categories":[],"tags":[{"name":"置顶","slug":"置顶","permalink":"http://example.com/tags/%E7%BD%AE%E9%A1%B6/"}],"keywords":[]},{"title":"GEB读书笔记","slug":"GEB","date":"2024-03-01T13:52:16.000Z","updated":"2024-03-01T13:57:17.755Z","comments":true,"path":"2024/03/01/GEB/","permalink":"http://example.com/2024/03/01/GEB/","excerpt":"","text":"开个大坑，准备读GEB的英文原著，这篇博客用来记录读书笔记和想法，先占个位。 希望半年内能读完吧。","categories":[],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}],"keywords":[]},{"title":"射影几何0","slug":"projective-geometry0","date":"2024-02-28T06:21:40.000Z","updated":"2024-03-02T08:21:31.094Z","comments":true,"path":"2024/02/28/projective-geometry0/","permalink":"http://example.com/2024/02/28/projective-geometry0/","excerpt":"","text":"准备有时间学一下射影几何，先占个坑。","categories":[],"tags":[],"keywords":[]},{"title":"浅谈约瑟夫环问题","slug":"josephus-problem","date":"2024-02-25T09:23:36.000Z","updated":"2024-03-03T06:51:54.245Z","comments":true,"path":"2024/02/25/josephus-problem/","permalink":"http://example.com/2024/02/25/josephus-problem/","excerpt":"","text":"浅谈约瑟夫环问题 Update:寄，写完了突然发现和oi-wiki上的几乎一模一样，脑回路神奇地重合了。 不过一些地方理解方式有些区别，只能说还是有点意义的。 0.前言 近日洛谷上看到了这道题P8671 [蓝桥杯 2018 国 AC] 约瑟夫环，发现自己对约瑟夫环的一些写法不太了解，所以记录一下。 1.问题叙述 本文讨论的约瑟夫环问题表述如下： 个人，从开始报数，数到的人淘汰，然后重新从报数，问最后一人的编号，为了讲述方便，我们规定编号从开始。 2.通用解法 2.1 暴力枚举 我们用链表储存现有的人，然后暴力枚举。这样做删除的复杂度为，寻找下一个人的复杂度为 (还有一种实现，对每个元素记录它之前和之后第个元素的编号，每删除一个元素后，对它前k个元素进行修改，删除的复杂度，但个人觉得实现比较复杂) 时间复杂度： 2.2 数据结构优化 注意到2.1的瓶颈在于寻找下一个被淘汰的人，我们考虑用数据结构优化。 我们改用数组存储每个人是否被淘汰，然后用线段树二分在的时间内寻找下一个元素。 时间复杂度： 另外，我们也可以用跳表等维护。 2.3 递推 这算是一个重点了，我们设表示个人，数到淘汰的前提下，最后剩下的人的编号，且编号从开始。 显然，我们考虑从个人开始添加人会使最后的幸存者的编号发生什么变化。 即已知，求 显然，个人开始游戏后，第一个被淘汰的人的编号为，我们会从编号的人开始报数，且此时只有个人，我们把这个人当作新的，那答案显然为，再将新编号换为原本的编号，我们就有 线性递推地做即可。 时间复杂度： 2.4 递推优化 观察2.3的式子，我们实际上没有必要在每次加上后都进行取模。只有当时，我们才需要减去，并且有 考虑只在需要取模时转移，设当前已求出人数为的情况，下一个需要取模的人数为，则 即 即 算出后，可以由 得到，然后将作为新的 按如上方式转移，直到对于当前求出的，然后得到 从而求出答案，注意时需要特判。 时间复杂度：的增长率大约为，因此使大于等于的时间复杂度约为 我们设 则 画图后观察到收敛很快，因此我们可以将近似为一条直线，斜率为在趋于正无穷时的极限，易得 由上述得， 时间复杂度为 当时上式较为准确，与大小相近时会有较大偏差。 3.一些其它结论 3.1 时的答案 当时，我们可以通过另一种方法得到答案。 假设，我们易得(每次所有人数过一遍后，剩下的人数仍为的幂) 所以当总人数为2的幂时，从谁开始，则谁为最后剩下的人。 那考虑一般情况 当淘汰了个人时，我们有 所以此时我们会从编号为的人开始，且只剩下个人，最后剩下的编号即为 所以对，有 3.2 对时答案的探索 4.推广问题 约瑟夫问题还可以进行一些推广。 比如每次淘汰数最后个数的人，求最后剩下的个人的编号。 等之后我有想法了再来补充。","categories":[{"name":"CS","slug":"CS","permalink":"http://example.com/categories/CS/"},{"name":"ACM","slug":"CS/ACM","permalink":"http://example.com/categories/CS/ACM/"},{"name":"数学","slug":"CS/ACM/数学","permalink":"http://example.com/categories/CS/ACM/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"},{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"CS","slug":"CS","permalink":"http://example.com/tags/CS/"}],"keywords":[{"name":"CS","slug":"CS","permalink":"http://example.com/categories/CS/"},{"name":"ACM","slug":"CS/ACM","permalink":"http://example.com/categories/CS/ACM/"},{"name":"数学","slug":"CS/ACM/数学","permalink":"http://example.com/categories/CS/ACM/%E6%95%B0%E5%AD%A6/"}]}]}