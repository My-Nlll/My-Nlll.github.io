{"meta":{"title":"Nlll的博客","subtitle":"","description":"","author":"Nlll","url":"http://example.com"},"pages":[{"title":"404","date":"2024-02-25T11:37:57.225Z","updated":"2024-02-25T11:37:57.225Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":"这是一个404界面，放张玛玛的美图 (如果你看不见，这是正常的，我还没放)"},{"title":"flag","date":"2024-03-02T08:52:28.000Z","updated":"2024-03-02T08:55:53.282Z","comments":true,"path":"flag/index.html","permalink":"http://example.com/flag/index.html","excerpt":"","text":"恭喜你找到了flag{Nlll's blog}"},{"title":"about","date":"2024-02-25T11:01:45.000Z","updated":"2024-02-25T11:01:45.765Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Raney引理在有序树上的应用","slug":"Raney-in-tree","date":"2024-07-14T11:25:46.000Z","updated":"2024-07-14T12:03:27.157Z","comments":true,"path":"2024/07/14/Raney-in-tree/","permalink":"http://example.com/2024/07/14/Raney-in-tree/","excerpt":"","text":"Raney引理在有序树上的应用 目录: 零.前言 一.约定说明 二.问题引入 三.寻找组合解释 四.应用 五.现在，让我们更进一步 六.森林上的应用 七.一些想法 零.前言 这篇文章写于今年一月份，但因为想在校赛上放一道相关题目(虽然最后也没放)，所以拖到现在才发。 现在重看，感觉当时写的有很多地方不够好，可能等有时间了重置一下吧。 一.约定说明 1.有序树: 若将树中每个结点的各子树看成是从左到右有次序的(即不能互换)，则称该 树为有序树(Ordered Tree)。 2.有序森林: 森林中每颗树都是有序的，且树之间也是有序的。 二.问题引入 在学习生成函数的过程中，我们遇到过这样一个问题：求解不同构的个节点的有序叉树的个数。而通常的求解是表示出其对应的生成函数后用拉格朗日反演得到答案，即。注意到当时，答案就是我们熟知的卡特兰数，但形式略有不同。 我们不妨猜测我们求得的叉树计数公式应该与二叉树一样具有某种组合意义。(毕竟这种看起来很组合的计数问题却只能通过拉格朗日反演得到答案什么的太怪了) Update: 翻洛谷的时候发现这个结论其实早就有人发现了，但好像没人在意。可以看P2767 pufanyi 的题解。 三.寻找组合解释 1.部分 众所周知，组合数的意义即是从个元素中无序地选择个元素。暴力地套在公式中的组合数上，我们可以得到叉树的计数公式的主要部分即从个元素中无序地选取个元素。我们很容易联想到应该与树的条边有关，那么就因该指d叉树中所有可能的条边。但注意到，想要使条边不等价，我们需要为每个点赋予不同的编号。综上，我们可以认为，部分代表我们以某种特定的方式为每个点赋予编号后从每个点可能的条边中共选取条作为树边的方案数。 2.给点分配编号的方法 考虑如何按照某种规则使得每颗叉树上的点都具有编号。不难想到，根据树的有序性，我们考虑按照边的顺序从前往后来dfs遍历每个点，这样得到的dfs序就是唯一确定的。 PS：这种方法实际上并不要求我们一定要让每条边初始时都有先后顺序。例如依存树，其左区域和右区域中边有顺序，而我们可以规定先访问左区域中的边在访问右区域的边，这样也可以确定唯一的顺序，总而言之，一颗有序树因为它的边互不等价，我们总可以规定一种唯一的顺序。 3.部分 终于，我们来到问题最关键的一部分了，先让我们想想为什么会有这个系数。答案很显然，不是每种选择边的方案都会使构成的树合法。 例如，我们考虑一颗个节点的二叉树，其中第条边代表结点的左边，第条边代表结点i的右边。则选取 1，3，6，8 对应的树如下图，是合法的。 合法情况 而选取 1，4，6，9 对应的树如下图，是不合法的。 不合法情况 我们考虑用从到加点的方式构造，那么显然不合法的原因就是个点在全部加入前，某些点已经形成了一颗树。我们想要证明，有办法把所有情况分组，每组有种情况且每组中有且仅有种情况是合法的。不妨猜测，有一种分组方案可以使这种情况有某些关联。 实际上，一种满足要求的分组方案如下，我们任意选取一种方案，如 1，4，6，9 将其改记为每个点有的边，即 1：左 右 ，2：空 ，3：空 ，4：左 右 ，5：空 然后让每个点拥有的边做轮换，即变成 1：空 ，2：左 右 ，3：空 ，4：空 ，5：左 右 这样不断轮换可以得到n种情况，把这n种情况分为一组，那么 1，4，6，9对应的组为&lt; 1，4，6，9 &gt;，&lt; 2，5，7，10 &gt;，&lt; 1，3，6，8 &gt;，&lt; 2，4，7，9 &gt;，&lt; 3，5，8，10&gt; 显然其中只有&lt; 1，3，6，8 &gt;是合法的。 下面是其正确性的证明： 首先，我们仿照卡特兰数的证明，将问题转换。考虑我们还能加入的点的数量，记其为，初始时(我们加入的第一个点就是根节点，也可以想象这里有一条虚边)。当我们加入一个有条边的点后，会加上(因为新加的点占用了一条边，同时它有条新的边)。显然，当所有边加入后，。如果还有点没有加入时，，那么这种情况就是不合法的，因为它代表加入部分点后，所有的边已经被点占用，即已经形成了一颗树。 现在，我们就可以把点抽象为一个值，且所有值的总和为，初始时，合法方案为加入最后一个值前始终有(这里为了方便证明，把的初始值改为，终点改为)。我们接下来证明按上述方法分组后，每组一定有且仅有一种方案合法。 Update：以下内容其实就是Raney定理，这里用该定理直接就可以证明了。 我们可以把个点排成一个有顺序的环，然后定义起点为第一个加入的点的前面一个点，那么上述分组意味着我们可以选择任意一个点为起点，按顺序加值，直到把起点对应的值加上。 先证至少有一个合法方案，我们先随便选择一种方案①，起点记为，若其合法，则成立，否则，设其过程中的最小值为，然后以最先使的点为起点，记该点为，记这种方案为方案②。设方案②中某点值为，方案①中某点值为(，代表同一点在不同方案下的值)，我们有。的这一段，因为的值从变为，所以。加入点后，，因为是方案中从开始最先使的且，所以在这一段中，。最后加入A点后，，综上，方案②中在加上点值前始终，是合法方案。 再证最多只有一种合法方案。假设存在两种合法方案①和②，记方案①的起点为，方案②的起点为，设方案①中某点值为，方案②中某点值为。 设加入点时，由方案①的合法性得，则加入点时，，又因为此时方案②未加入所有点，所以方案②显然不合法，矛盾。因此，最多存在一种合法方案。 综上，我们证明了系数的正确性。 4.总结 经过一些抽象的证明，我们终于找到了叉树计数公式的组合意义，但这显然不是我们费劲千辛万苦所得到结论的唯一用处。 实际上，注意系数的证明，我们其实并没有用到有关叉树的性质，这一结论对任意有序树都是成立的。也就是说，我们可以极大地扩展该结论的应用场景。 只要树是有根有序的(为了能给每个结点唯一编号)，且我们可以保证把任意一种边的方案作轮换后依然是一种可行的分配边的方案(保证系数)，我们都可以通过乘上的系数把树的计数问题转换为给个不同结点分配条边的问题，当然，不同的树会有不同的限制。 总而言之，通过这个只需简单的组合知识就可以证明的结论，我们可以把一类有根有序树的计数问题转化为有限制地把个相同小球装进个不同盒子。 四.应用 PS：注意使用隔板法时，若盒子数，要考虑其实际意义，基本上只要把隔板法的当作，其它含有负数的情况当作0就行。 1.依存树计数 问题：不同的个结点依存树的个数 先给出依存树的一个简单定义：依存树（Dependency trees）可以定义为由一个根节点、若干棵左子树和若干棵右子树构成(所有左子树或右子树间有顺序)，其中所有子树都是依存树。 转换为球盒问题，结点对应盒，边对应球。注意到结点的边可以属于两个不同的区域，我们不妨想象一个盒子中也有两个不同的区域可以放球，这本质上就等价于个不同的盒子，而我们共有个相同的球，由隔板法得方案数为。 然后把转换后问题的方案数再乘上的系数，得到答案为 2.多叉树(有根有序树)计数 多叉树就是一颗没有限制的有根有序树，转化后就是把个相同小球，放进个不同盒子，用隔板法得到答案为。 所以个结点的多叉树个数为。 PS：其实用多叉树与二叉树的转换也可以做，注意转换后的二叉树根节点一定只有左儿子，就相当于个结点的二叉树。 #### 3.限制叶子结点数量的有根有序树计数 问题：个结点的有根有序树且恰有个叶子结点的个数。 仍然是变为球盒问题，我们先选出个盒子不放球，方案数为，然后将个相同球放入剩下的个盒子中，且没有空盒子，由隔板法得方案数为。 因此答案为。 PS：当时，放球的盒子数为，不能直接用隔板法，要特判一下，若则答案为，否则为。 4.限制度数为的结点数量的有根有序树计数 问题：个结点的有根有序树，且度数为的结点恰有个的个数。 考虑一般化容斥，目标函数，通过，得到系数函数，有，然后至少有个度数为的结点的方案数为，所以方案数为。 答案为 特例：注意中有负数的组合数计算，当作，除了都当作，这是为了保证它作为隔板法的实际意义 5.一些更复杂的问题(不给过程) 我们还可以来回答一些更复杂的问题。 1.恰有个叶子结点，且度数为的结点恰有个的有根有序树计数 公式： 特例：注意中有负数的组合数计算，当作，除了都当作，这是为了保证它作为隔板法的实际意义 PS：其实的上限写成或者直接到好像也行，应用4也同理，但没什么必要。 2.对每个，度数为的结点至少有个的有根有序树计数 公式： 6.有个限制，第个限制为度数为的结点恰有个的有根有序树计数 我们记给定的的集合为，没有给定的度数的集合为。 问题转换不再叙述。 设，问题变为总度数为，点的数量为，且每个点度数不为中的元素，或者说必须为中元素。 设，第种元素的数量为，度数为。 Update: 其实最后答案的式子直接考虑组合意义就能得到，用EGF纯属当初傻了，但懒得改了。 得到以下式子： 考虑EGF形式： 然后多项式快速幂 / 取log算就行了。 答案为： 7.Luogu P7592 数树（2021 CoE-II E） 题目链接：P7592 数树 突然发现一道可以用结论切的黑题。 显然，加上我们舍掉的非法情况后得分的期望不会改变，因此直接看成球盒问题就行了。 个相同的球，放入个不同盒子，每个盒子只能放或个球，且得分分别为和，求期望得分。 我们设放了个球的盒子有个，放了个球的盒子有个，显然，对于每个可能的都有唯一的，因此直接枚举就可以，时间复杂度，式子如下： 五.现在，让我们更进一步 首先，我们详细说明一下上文可以用Raney引理证明的地方。 我们应该反过来考虑，这样就保证了所有操作的轴和，并且，注意到这产生了一个新的性质 (其实你可以发现我们可以让树的儿子个数不为整数，但我不知道这能被赋予什么意义，可能类似矩阵树的一些题，和概率有关？) 然后，我们可以根据Raney引理的一个扩展形式来得到新的结论。 扩展形式见广义二项/指数级数？广义卡塔兰/凯莱数！ 这告诉我们，如果我们把终点改为，则只需将系数从变为即可。 那么这对应了什么呢？ 不难想到，这代表了一个具有颗树的有序森林，其中森林有序是指森林中树之间有顺序。 所以，我们可以把上述树的计数放到森林上去做，所改变的不过是一个系数。 六.森林上的应用 七.一些想法 贴一些感兴趣的文章的链接： https://x-yi-x.blog.uoj.ac/blog/6511 https://www.luogu.com/article/mqa5ibwe Update:稍微写一下应用3的拉格朗日反演写法。 设为方案数的GF，用于计量结点个数，用于计量叶子结点个数。 有 对用拉格朗日反演得 答案为","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"CS","slug":"CS","permalink":"http://example.com/tags/CS/"},{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}],"keywords":[]},{"title":"2024四川省赛","slug":"2024SC","date":"2024-06-15T10:58:21.000Z","updated":"2024-07-14T11:16:56.439Z","comments":true,"path":"2024/06/15/2024SC/","permalink":"http://example.com/2024/06/15/2024SC/","excerpt":"","text":"2024四川省赛 0.前言 期末周自己VP了一场，赛时过了8题(大概？)，之后补了一下，感觉都可做(主要没有字符串和计算几何)，但好多能做的东西确实感觉有点生疏了，比如K的SOS和C的网络流，都想了好久。 比赛链接: 2024 年第十六届四川省大学生程序设计竞赛 A.逆序对染色 思维题，想了挺久。 首先，不难想到肯定要从第一项到最后一项一层一层维护。 每一层染色的点有点像用一个遮罩遮住了后缀里的数。 每一层新增的连通块即上一层没有，但这一层有的格子形成的联通块数量。 那不考虑后缀的改变的话，直接考虑本层联通块数量减去上一层连通块数量即可。 现在，考虑后缀改变。 显然，经过第层后，第列的格子永远不会被染色。 因此，我们不妨将每层前格连通块数量转换到前格不会被染色的格子的连通块数量上。 容易发现基本上两者是相等的。 但需要处理最前面和最后面连通块的情况。 最后面的连通块即考虑不会染色的第列加入后是否会和前面的不会染色的列形成连通块，如果形成，那么染色的连通块就会少。我的做法是先把第列加入不会染色的块，然后如果形成了连通块，那不染色的连通块也自然少了 最前面的情况就是不会染色的连通块是否包含了第列，如果包含，那染色连通块数量也会少，我的做法是假设有第列存在，显然含第列的连通块最多有个，即我们计算时包含第列的连通块，那么这就不会有影响，但要特判第一个数是的情况，因为此时并没有含的连通块，要把答案减去 最后，说一下如何维护不染色连通块，我们可以用一个set维护目前各连通块的区间，当加入一个数时，分别向前向后将相邻的区间加起来。 求连通块数量时，只需查询set里左端点小于查询数的元素个数即可，但set好像没有做这个的功能？于是我又写了个线段树，维护每个点是否是区间的左端点。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int Maxn=3e5+5;int n,a[Maxn];int s[Maxn&lt;&lt;2];struct node{ int li;int ri; node(int lii=0,int rii=0) { li=lii;ri=rii;return; } bool operator &lt; (const node &amp;x)const { return li&lt;x.li; }}; set&lt;node&gt; S;void Pup(int k){ int k1=k&lt;&lt;1,k2=k1|1; s[k]=s[k1]+s[k2]; return; }void Add(int k,int l,int r,int x,int w){ if(l==r){s[k]+=w;return;} int m=(l+r)&gt;&gt;1,k1=k&lt;&lt;1,k2=k1|1; if(x&lt;=m){Add(k1,l,m,x,w);} else{Add(k2,m+1,r,x,w);} Pup(k); return;}int Que(int k,int l,int r,int L,int R){ if(L&lt;=l&amp;&amp;R&gt;=r){return s[k];} int m=(l+r)&gt;&gt;1,k1=k&lt;&lt;1,k2=k1|1,ans=0; if(L&lt;=m){ans=Que(k1,l,m,L,R);} if(R&gt;m){ans+=Que(k2,m+1,r,L,R);} return ans;}void Ins(node x){ S.insert(x); node z; set&lt;node&gt;::iterator it,it2; it=S.find(x);it2=it;it2++; if(it2!=S.end()) { z=*it2; if(z.li==x.ri+1) { Add(1,1,n,z.li,-1); x=node(x.li,z.ri); S.erase(it2);S.erase(it); S.insert(x); it=S.find(x); } } if(it!=S.begin()) { it2=it;it2--; z=*it2; if(z.ri==x.li-1) { x=node(z.li,x.ri); S.erase(it);S.erase(it2); S.insert(x); return; } } Add(1,1,n,x.li,1); return;}int main(){ int Now=0,Last=0;ll ans=0; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); } if(a[1]==1){ans=-1;} for(int i=1;i&lt;=n;i++) { Ins(node(a[i],a[i])); Now=Que(1,1,n,1,a[i]); if(Now&gt;Last) { ans+=Now-Last; } Last=Now; } printf(\"%lld\\n\",ans); return 0;} B.连接召唤 分类讨论即可。 合成的顺序显然是要保证每次合成消耗的怪物数量尽可能少。 所需数量相同时，尽量把大的留后头。 还有一些细节，直接看代码吧。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll a[15];int main(){ int T=0,x=0;ll ans=0,N=0; scanf(\"%d\",&amp;T); while(T--) { ans=0; for(int i=1;i&lt;=5;i++) { scanf(\"%lld\",&amp;a[i]); } N=min(a[2],a[4]); a[4]-=N;a[2]-=N;ans+=N; ans+=a[3]/2;a[3]%=2; x=1; while(a[5]&amp;&amp;x!=5) { N=min(a[x],a[5]); a[5]-=N;a[x]-=N;ans+=N; x++; } if(a[5]) { ans+=a[5]/2; a[5]%=2; } if(a[4]) { N=min(a[1]/2,a[4]); a[4]-=N;a[1]-=N*2;ans+=N; if(a[1]&amp;&amp;a[3]&amp;&amp;a[4]) { a[4]--;a[3]--;a[1]--; ans++; } if(a[1]+a[3]&amp;&amp;a[4]&gt;=2) { a[4]-=2;a[1]=0;a[3]=0; ans++; } } if(a[4]) { ans+=a[4]/3; a[4]%=3; } if(a[3]&amp;&amp;a[2]&amp;&amp;a[1]) { a[1]--;a[2]--;a[3]--; ans++; } if(a[3]&amp;&amp;a[2]&gt;=2) { a[3]--;a[2]-=2; ans++; } if(a[3]&amp;&amp;a[1]&gt;=3) { a[3]--;a[1]-=3; ans++; } ans+=(a[1]+a[2]*2)/6; printf(\"%lld\\n\",ans); } return 0;} C.黑白立方格 将题意翻译一下，就是如果某格为白色，则所有三维都比它大的格子也一定为白色。 想象一下几何形状，可以简化成 然后就是网络流经典做法，但我忘了()。 于是想了半天才想起来。 我们可以用最大权闭合子图做。 先假设我们把所用黑色都翻成白色。 则花费为所有黑色格子的权值和。 现在，我们考虑建图，当我们选择一个格子并决定将其改为时，一定都要变为黑色，即都要选择它们。 权值的绝对值即翻面的成本，对于原本是黑色的格子，权值为正，否则为负。 注意一下和的限制即可。 实现我是从全变黑色的角度考虑的，所以略有不同。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int Inf=1e9+7;const int Maxn=5e3+5;queue&lt;int&gt; q;int ans,n,m,l;int cnt=1,u[Maxn],Next[Maxn&lt;&lt;4],To[Maxn&lt;&lt;4],Flow[Maxn&lt;&lt;4];int dis[Maxn],Now[Maxn],In[Maxn],Out[Maxn];inline void adde(int x,int y,int f){ cnt++;Next[cnt]=u[x];u[x]=cnt;To[cnt]=y;Flow[cnt]=f; cnt++;Next[cnt]=u[y];u[y]=cnt;To[cnt]=x;Flow[cnt]=0; return;}bool Bfs(int s,int t){ int x=0,Zc=0; memset(dis,0,sizeof(dis)); dis[s]=1;q=queue&lt;int&gt;();q.push(s); while(!q.empty()) { x=q.front();q.pop();Now[x]=u[x]; for(int i=u[x];i;i=Next[i]) { Zc=To[i]; if(!dis[Zc]&amp;&amp;Flow[i]) { dis[Zc]=dis[x]+1;q.push(Zc); } } } if(!dis[t]){return 0;} return 1;}int Dfs(int x,int t,int Min){ int Ma=0,Mi=0,Zc=0; if(x==t){ans=ans+Min;return Min;} for(int i=Now[x];i;i=Next[i]) { Zc=To[i];Now[x]=i; if(dis[Zc]==dis[x]+1&amp;&amp;Flow[i]) { Mi=Dfs(Zc,t,min(Min-Ma,Flow[i])); if(Mi) { Ma=Ma+Mi;Flow[i]=Flow[i]-Mi;Flow[i^1]=Flow[i^1]+Mi; if(Ma==Min){break;} } } } return Ma;}int Calc(int x,int y,int z){ return (x-1)*m*l+(y-1)*l+z;}char c[Maxn];int col[Maxn],a[Maxn]; int main(){ int s=0,t=0,N=0; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;l); s=n*m*l+1;t=n*m*l+2; for(int k=1;k&lt;=l;k++) { for(int i=1;i&lt;=n;i++) { scanf(\"%s\",c+1); for(int j=1;j&lt;=m;j++) { if(c[j]=='W') { col[Calc(i,j,k)]=1; } else { col[Calc(i,j,k)]=0; } } } } for(int k=1;k&lt;=l;k++) { for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { scanf(\"%d\",&amp;a[Calc(i,j,k)]); } } } for(int k=1;k&lt;=l;k++) { for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { N=Calc(i,j,k); if(N==1) { if(col[N]==1) { ans+=a[N]; } a[N]=Inf; col[N]=0; } if(N==n*m*l) { if(col[N]==0) { ans+=a[N]; } a[N]=Inf; col[N]=1; } if(col[N]) { adde(s,N,a[N]); } else { adde(N,t,a[N]); } if(i!=n){adde(N,Calc(i+1,j,k),Inf);} if(j!=m){adde(N,Calc(i,j+1,k),Inf);} if(k!=l){adde(N,Calc(i,j,k+1),Inf);} } } } while(Bfs(s,t)){Dfs(s,t,Inf);} printf(\"%d\\n\",ans); return 0;} D. L 型覆盖 显然可做，但VP时没时间了。 首先，面积模不为的情况显然非法。 然后，一个容易的观察是是简单的。 那么我们可以用它组合出和 于是发现对于任意，和都是可以组合出来的。 那么我们只需要考虑边长模后的情况就可以了，吗？ 当边长模后某边为时，显然无解，但我们不能保证此时真的无解，因此我们把其当作对待。(注意原题保证边长一定大于) 然后就是小情况手动构造一下，大致有，。 除了都挺好想的，在 . 格旁边的处理与其它情况不太一样。 实现比较丑陋，将就看吧。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include&lt;bits/stdc++.h&gt;using namespace std;const int Maxn=505;int Nowx,Nowy;char ans[Maxn][Maxn];pair&lt;int,int&gt; nm[12]={{2,6},{3,6},{6,2},{6,3},{2,2},{4,4},{5,5},{7,7},{2,5},{5,2},{4,7},{7,4}};vector&lt;string&gt; Ans[12]={ //0-26 { \"DRCDRC\", \"CLUCLU\" }, //1-36 { \"RCRCRC\", \"DUDUDU\", \"CLCLCL\" }, //2-62 { \"CL\", \"UD\", \"RC\", \"CL\", \"UD\", \"RC\" }, //3-63 { \"DRC\", \"CLU\", \"DRC\", \"CLU\", \"DRC\", \"CLU\" }, //4-22 { \"D.\", \"CL\" }, //5-44 { \"CLD.\", \"UDCL\", \"DCLD\", \"CLRC\" }, //6-55 { \"CLCL.\", \"UDURC\", \"RCRCU\", \"CLDUD\", \"URCRC\" }, //7-77 { \"CLCLCL.\", \"UDUDURC\", \"RCRCRCU\", \"CLCLDUD\", \"UDURCRC\", \"DCLDCLD\", \"CLRCURC\" }, //8-25 { \"CLDD.\", \"URCCL\" }, //9-52 { \"D.\", \"CL\", \"CL\", \"UD\", \"RC\" }, //10-47 { \"DRCCLD.\", \"CLUUDCL\", \"DRCDCLD\", \"CLUCLRC\" }, //11-74 { \"CLD.\", \"UDCL\", \"DCLD\", \"CLRC\", \"CLCL\", \"UDUD\", \"RCRC\", }};void Assign(int op){ int n=nm[op].first,m=nm[op].second; int x=0,y=0; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { x=Nowx+i-1;y=Nowy+j-1; ans[x][y]=Ans[op][i-1][j-1]; } } return;}void Solve(int n,int m){ int x=0,y=0; Nowx=1,Nowy=1; while(m-Nowy+1&gt;7) { Nowx=1; while(n-Nowx+1&gt;4) { Assign(1); Nowx+=3; } if(n-Nowx+1==4) { Assign(0); Nowx+=2; Assign(0); } else if(n-Nowx+1==3) { Assign(1); } else { Assign(0); } Nowy+=6; } y=Nowy; Nowx=n%6+1; if(Nowx==2){Nowx=8;} while(Nowx&lt;=n) { Nowy=y; while(m-Nowy+1&gt;4) { Assign(3); Nowy+=3; } if(m-Nowy+1==4) { Assign(2); Nowy+=2; Assign(2); } else if(m-Nowy+1==3) { Assign(3); } else { Assign(2); } Nowx+=6; } Nowx=1;Nowy=y; x=n%6;y=m%6; if(x==1){x=7;} if(y==1){y=7;} if(x==2&amp;&amp;y==2) { Assign(4); } if(x==4&amp;&amp;y==4) { Assign(5); } if(x==5&amp;&amp;y==5) { Assign(6); } if(x==7&amp;&amp;y==7) { Assign(7); } if(x==2&amp;&amp;y==5) { Assign(8); } if(x==5&amp;&amp;y==2) { Assign(9); } if(x==4&amp;&amp;y==7) { Assign(10); } if(x==7&amp;&amp;y==4) { Assign(11); } return;}int main(){ int T=0,n=0,m=0; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d%d\",&amp;n,&amp;m); if(n*m%3==1) { Solve(n,m); puts(\"Yes\"); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { putchar(ans[i][j]); } putchar('\\n'); } } else { puts(\"No\"); } } return 0;} E. L 型覆盖检查器 语法题。 对每个C检查其上下和左右是否各有一个指向它，然后检查.的位置和其它字符是否指向C，照着题意弄就行。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int Maxn=505;char c[Maxn];int a[Maxn][Maxn],b[Maxn][Maxn],d[Maxn][Maxn];int main(){ int T=0,n=0,m=0,ok=0,n1=0,n2=0,n3=0,pd=0; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(\"%s\",c+1); for(int j=1;j&lt;=m;j++) { if(c[j]=='.') { if(i==1&amp;&amp;j==m) { ok=1; } else { pd=1; } } else if(c[j]=='U') { if(i==1){pd=1;} else{a[i-1][j]++;} } else if(c[j]=='D') { if(i==n){pd=1;} else{a[i+1][j]++;} } else if(c[j]=='L') { if(j==1){pd=1;} else{b[i][j-1]++;}; } else if(c[j]=='R') { if(j==m){pd=1;} else{b[i][j+1]++;} } else { d[i][j]++; } } } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { if(d[i][j]&amp;&amp;(!a[i][j]||!b[i][j])) { pd=1;break; } if(!d[i][j]&amp;&amp;(a[i][j]||b[i][j])) { pd=1;break; } } } if(pd||!ok) { puts(\"No\"); } else { puts(\"Yes\"); } ok=0;pd=0; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { a[i][j]=0;b[i][j]=0;d[i][j]=0; } } } return 0;} F.小球进洞：平面版 分别求出轴，轴上满足条件的时间，看是否有交集即可。 注意一些特判就行，然后本题精度要求高，实现没用浮点数。 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int main(){ int T=0,n=0; ll x=0,y=0,r=0,vx=0,vy=0,lx=0,ly=0,rx=0,ry=0; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%lld%lld%lld%lld%lld\",&amp;x,&amp;y,&amp;r,&amp;vx,&amp;vy); scanf(\"%lld%lld%lld%lld\",&amp;lx,&amp;ly,&amp;rx,&amp;ry); if(vx&lt;0){x=-x;vx=-vx;swap(lx,rx);lx=-lx;rx=-rx;} if(vy&lt;0){y=-y;vy=-vy;swap(ly,ry);ly=-ly;ry=-ry;} if(rx-lx&lt;r*2||ry-ly&lt;r*2){puts(\"No\");continue;} if(!vx) { if(x-r&lt;lx||x+r&gt;rx){puts(\"No\");continue;} if(y+r&gt;ry){puts(\"No\");continue;} puts(\"Yes\");continue; } if(!vy) { if(y-r&lt;ly||y+r&gt;ry){puts(\"No\");continue;} if(x+r&gt;rx){puts(\"No\");continue;} puts(\"Yes\");continue; } if((vy*(rx-x-r)&gt;=vx*max(0ll,ly-y+r))&amp;&amp;(vx*(ry-y-r)&gt;=vy*max(0ll,lx-x+r))) { puts(\"Yes\"); } else { puts(\"No\"); } } return 0;} G.函数查询 不难发现问题可以转换为，是否对所有，都同号且不为。 判断是否有解只需求出对所有，的最大最小值即可，即计算的最大最小值。 可以用trie树实现。 当求出最大最小值后，显然最大最小值对应的的区间中一定包含相邻的两个值异号或为，证明可以想一下零点定理。 按照求零点的二分法二分位置即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int Maxn=3e5+5;const int Lim=30;ll c[Maxn];ll t[Maxn&lt;&lt;5];int cnt=1,Son[2][Maxn&lt;&lt;4],pos[Maxn&lt;&lt;5];int ma,mi;void Ins(ll x,int y){ int z=0,Now=1; for(int i=Lim;i&gt;=0;i--) { z=(x&amp;(1ll&lt;&lt;i)?1:0); if(!Son[z][Now]) { cnt++;Son[z][Now]=cnt; } Now=Son[z][Now]; } t[Now]=x; if(!pos[Now]){pos[Now]=y;} pos[Now]=min(pos[Now],y); return;}ll Get_Max(ll x){ int z=0,Now=1;ll ans=0; for(int i=Lim;i&gt;=0;i--) { z=(x&amp;(1ll&lt;&lt;i)?1:0); z^=1; if(!Son[z][Now]) { Now=Son[z^1][Now]; } else { Now=Son[z][Now]; } } ans=t[Now]^x;ma=pos[Now]; return ans;}ll Get_Min(ll x){ int z=0,Now=1;ll ans=0; for(int i=Lim;i&gt;=0;i--) { z=(x&amp;(1ll&lt;&lt;i)?1:0); if(!Son[z][Now]) { Now=Son[z^1][Now]; } else { Now=Son[z][Now]; } } ans=t[Now]^x;mi=pos[Now]; return ans;}ll Calc(ll a,ll b,int x){ return (a^c[x])-b;}int main(){ int n=0,q=0,l=0,r=0,m=0; ll x=0,y=0,a=0,b=0; scanf(\"%d%d\",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) { scanf(\"%lld\",&amp;c[i]); Ins(c[i],i); } for(int i=1;i&lt;=q;i++) { scanf(\"%lld%lld\",&amp;a,&amp;b); x=Get_Max(a)-b; y=Get_Min(a)-b; if(x*y&gt;0) { printf(\"-1\\n\");continue; } l=min(ma,mi);r=max(ma,mi)-1; while(l&lt;r) { m=(l+r+1)&gt;&gt;1; if(Calc(a,b,l)*Calc(a,b,m)&lt;=0) { r=m-1; } else { l=m; } } printf(\"%d\\n\",l); } return 0;} H. GG 和 YY 的石子游戏 基础博弈论，保证胜利的前提下一定拿 代码： 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int main(){ int T=0;ll n=0; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%lld\",&amp;n); if(n%3) { printf(\"0 %lld\\n\",n%3+n/3); } else { printf(\"1 %lld\\n\",n/3); } } return 0;} I.集装箱调度 容易想到除了第一个可能装进去的集装箱以外，剩余集装箱的位置一定与其它集装箱有交点。 否则，集装箱一定可以往一个更小的位置位移。 那么，考虑所有可能的交点，显然轴和轴一定都为或其它集装箱的边界所在直线。 个数为 于是，只需枚举所有可能交点，选择最小的合法交点即可。 判断合法只需枚举之前装进去的集装箱和正在装的集装箱是否相交面积不为即可，时间复杂度。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;const int Maxn=55;const int Inf=1e9+7;struct node{ int xi;int yi; node(int xii=0,int yii=0) { xi=xii;yi=yii;return; } bool operator &lt; (const node &amp;x)const { if(xi==x.xi) { return yi&lt;x.yi; } return xi&lt;x.xi; }};node a[Maxn],p[Maxn];int cnt1,cnt2,L,H;int zh1[Maxn&lt;&lt;4],zh2[Maxn&lt;&lt;4];void Ins(node x,node y){ int x1=0,x2=0,y1=0,y2=0; x1=x.xi;x2=x.xi+y.xi; y1=x.yi;y2=x.yi+y.yi; cnt1++;zh1[cnt1]=x1; cnt1++;zh1[cnt1]=x2; cnt2++;zh2[cnt2]=y1; cnt2++;zh2[cnt2]=y2; return;}bool Check(node x,node y,int N){ int x1=0,x2=0,x3=0,x4=0,y1=0,y2=0,y3=0,y4=0; int xx1=0,xx2=0,xx3=0,xx4=0,yy1=0,yy2=0,yy3=0,yy4=0; node z,w; if(x.xi+y.xi&gt;L||x.yi+y.yi&gt;H) { return 0; } for(int i=1;i&lt;N;i++) { if(p[i].xi==Inf){continue;} z=p[i];w=a[i]; x1=x.xi;y1=x.yi; x2=x.xi+y.xi;y2=x.yi; x3=x.xi;y3=x.yi+y.yi; x4=x.xi+y.xi;y4=x.yi+y.yi; xx1=z.xi;yy1=z.yi; xx2=z.xi+w.xi;yy2=z.yi; xx3=z.xi;yy3=z.yi+w.yi; xx4=z.xi+w.xi;yy4=z.yi+w.yi; if(xx4&gt;x1&amp;&amp;yy4&gt;y1&amp;&amp;xx1&lt;x4&amp;&amp;yy1&lt;y4){return 0;} if(xx3&lt;x2&amp;&amp;yy3&gt;y2&amp;&amp;xx2&gt;x3&amp;&amp;yy2&lt;y3){return 0;} } return 1;}int main(){ int n=0,Nu=0; node z,w; cnt1=cnt2=1;zh1[1]=zh2[1]=0; scanf(\"%d%d%d\",&amp;n,&amp;L,&amp;H); for(int i=1;i&lt;=n;i++) { scanf(\"%d%d\",&amp;a[i].xi,&amp;a[i].yi); z=node(Inf,Inf); for(int j=1;j&lt;=cnt1;j++) { for(int k=1;k&lt;=cnt2;k++) { w=node(zh1[j],zh2[k]); if(w&lt;z&amp;&amp;Check(w,a[i],i)) { z=w; } } } p[i]=z; if(z.xi!=Inf) { Ins(z,a[i]); printf(\"%d %d\\n\",z.xi,z.yi); } else { printf(\"-1\\n\"); } } return 0;} J.罗马数字 对于罗马数字直接和普通的取最小值即可。 剩余的罗马数字显然当前位为才可以用。 记忆化搜索(虽然我的代码没用记忆化)即可，时间复杂度没证，但感觉是不多的，回头可以证一下。 大概思路就是很难连续存在多个可用罗马数字的情况，比如，用一次后下一次或下两次一定不能用，再比如，只有用才能保证下一次还能用，情况感觉不会很多且难卡。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll Inf=1e18; ll c[15],r[15],a[15];ll Solve(ll x){ if(!x){return 0;} ll z=x%10; if(z) { return Solve((x-z)/10)+c[z]; } ll ans=Inf; for(int i=3;i&lt;=7;i++) { if(x&lt;a[i]){break;} ans=min(ans,Solve((x-a[i])/10)+r[i]); } ans=min(ans,Solve(x/10)+c[0]); return ans;}int main(){ int T=0;ll ans=0,n=0; a[3]=10;a[4]=50;a[5]=100;a[6]=500;a[7]=1000; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%lld\",&amp;n); for(int i=0;i&lt;=9;i++) { scanf(\"%lld\",&amp;c[i]); } for(int i=1;i&lt;=7;i++) { scanf(\"%lld\",&amp;r[i]); } c[1]=min(c[1],r[1]);c[5]=min(c[5],r[2]); ans=Solve(n); printf(\"%lld\\n\",ans); } return 0;} K.元素反应 考虑每个位置挂上元素可能的贡献。 显然，它会由离它最近且非惰性的元素种类决定。 所以，我们只需枚举可能的元素种类即可。 假设我们考虑的位置为，和它反应的元素位置为 则中所有存在的元素一定为惰性，且对应的元素一定为非惰性。 假如去掉一定非惰性的条件，则我们不难想到状压，用表示非惰性，表示惰性。 那么假设一定惰性的条件为，实际惰性情况为 当时，枚举的该位置与对应的元素种类会对这种情况产生贡献。 这可以直接用SOS处理。 接下来，考虑用容斥处理非惰性。 不难想到，在对应种类某一种为时减去该贡献，在对应种类均为时加上该贡献即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int Maxn=1e5+5;int n,m,v[Maxn],N;ll a[25][25];ll f[Maxn&lt;&lt;3];char c[Maxn];void Sos(){ for(int j=0;j&lt;m;j++) { for(int i=0;i&lt;N;i++) { if((i&gt;&gt;j)&amp;1) { f[i]+=f[i^(1&lt;&lt;j)]; } } } return;}int main(){ scanf(\"%d%d\",&amp;m,&amp;n); N=1&lt;&lt;m; for(int i=0;i&lt;m;i++) { for(int j=0;j&lt;m;j++) { scanf(\"%lld\",&amp;a[i][j]); } } scanf(\"%s\",c+1); for(int i=1;i&lt;=n;i++) { v[i]=c[i]-'a'; } vector&lt;int&gt; Next(m); for(int i=0;i&lt;m;i++) { Next[i]=-1; } int x=0,y=0,z=0; ll Need=0; for(int i=n;i;i--) { Need=0;x=v[i]; for(int j=0;j&lt;m;j++) { y=Next[j]; if(Next[j]==-1) { z=j;break; } f[Need]+=a[x][y]; f[Need|(1&lt;&lt;x)]-=a[x][y]; f[Need|(1&lt;&lt;y)]-=a[x][y]; f[Need|(1&lt;&lt;x)|(1&lt;&lt;y)]+=a[x][y]; Need=Need|(1&lt;&lt;y); if(x==y){z=j;break;} } Next.erase(Next.begin()+z); Next.insert(Next.begin(),x); } Sos(); for(int i=0;i&lt;N;i++) { printf(\"%lld \",f[i]); } return 0;} L.毛肚下清汤？ 语法题，按题意模拟即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const int Maxn=1e5+5;struct Food{ int ok1;int ok2;int nu; int t1;int t2; void Read() { scanf(\"%d%d%d%d\",&amp;t1,&amp;t2,&amp;ok1,&amp;ok2); return; }};Food a[Maxn],b[Maxn],c[Maxn];int op;bool my_cmp(const Food &amp;x,const Food &amp;y){ if(!op) { return x.t1&lt;y.t1; } else { return x.t2&lt;y.t2; }}int main(){ int n=0,x=0,y=0; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { a[i].Read();a[i].nu=i; if(!a[i].ok1) { y++;c[y]=a[i]; } else if(!a[i].ok2) { x++;b[x]=a[i]; } else { if(a[i].t1&lt;a[i].t2) { x++;b[x]=a[i]; } else { y++;c[y]=a[i]; } } } op=0;sort(b+1,b+x+1,my_cmp); op=1;sort(c+1,c+y+1,my_cmp); printf(\"%d \",x); for(int i=1;i&lt;=x;i++) { printf(\"%d \",b[i].nu); } putchar('\\n'); printf(\"%d \",y); for(int i=1;i&lt;=y;i++) { printf(\"%d \",c[i].nu); } putchar('\\n'); return 0;}","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"CS","slug":"CS","permalink":"http://example.com/tags/CS/"},{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"}],"keywords":[]},{"title":"2024暑假训练","slug":"2024summer-plan","date":"2024-06-03T11:00:16.000Z","updated":"2024-06-03T12:04:03.354Z","comments":true,"path":"2024/06/03/2024summer-plan/","permalink":"http://example.com/2024/06/03/2024summer-plan/","excerpt":"","text":"2024暑假训练 0.前言 简单记录一下今年暑假训练的题目和内容。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"plan","slug":"plan","permalink":"http://example.com/tags/plan/"}],"keywords":[]},{"title":"2024陕西省赛游记","slug":"SNCPC2024-travels","date":"2024-06-03T10:57:20.000Z","updated":"2024-06-03T12:02:08.758Z","comments":true,"path":"2024/06/03/SNCPC2024-travels/","permalink":"http://example.com/2024/06/03/SNCPC2024-travels/","excerpt":"","text":"2024陕西省赛游记 虽然说是游记，但主要还是打太烂了记录一下。 还是先赞美一下西交的组织，除了键盘回车有点抽象外都很好，场地只能说受限于校区硬件了。 至于题目，除了难度分级有点抽象并且实在对不上脑电波(你跟我说K比E难?)以外，单论题目本身都挺好的，也没有什么大锅。 奖杯很好看，可惜被薄纱根本捧不了杯，希望有生之年能捧次杯吧(但还是更希望明年因为众所周知的原因打星)。 说一下这场的过程，热身赛还是挺顺利的，因为机子有点问题，签完三道题基本就结束了，然后找高中同学聊了一会天就开始正式赛了。 前期签到速度中规中矩吧，大家都差不多的样子，签完四题后，去听了队友C的思路发现不对，又发现被同校另一支队n+1后有点慌了，口胡了一个假做法就上机去写，现在看来这时候可能就为之后的崩盘埋下伏笔。 C写了半天挂了4发后终于改对，此时发现前面十几支队的过题数都一样就稍微冷静了一点。听队友讲完K后，否了队友的二分做法，转而口胡了一个实现十分麻烦的做法(赛后又仔细想了想发现做法还假了，只能说我不愧是本场最大战犯)，然后立马上机去写，并让队友看一下L的结论。 写了20分钟后，发现我的做法实在是太难实现，于是给另一个代码能力稍微好点的队友讲了一下想让他写，但他表示他也不会()，于是在机上卡了半天基本什么都没写，终于队友把L结论证出来了，赶紧写了一下后下机，让队友去写他的B。 随后感觉K只要花时间实现就行(事实证明，这是一个愚蠢的决定)，于是去开了其它题，队友看了一下E和J表示没什么思路，我则是去看了I之后又很快贡献了一个假做法，并且直到结束都没改对。 之后就是帮队友改了下B，上机写I的假做法，发现wa了之后看着I自闭，封榜后，队友终于会了K的正解，结果是被我否掉的二分，于是去写。我终于接受I的做法不对后，去继续看E，可惜完全没思路。 队友写K时又发生了一些迷惑的事情导致最后也没开出来，结束的同时终于把造的小数据给过了，可惜交不上去也不知道改对没有。 总结一下，作为本场最大战犯的我除了一堆罚时和假做法外几乎没有什么贡献，队友的表现也一般，整个上机时间感觉不超过3小时，有效时间更是感觉连两个半小时都没有，只能说再次刷新了我们队的下限。 主要说一下自己的问题吧，感觉还是有点浮躁了，前两场邀请赛的发挥都不错，好几道Mid的题目都是一眼切的，再加上赛前想要捧杯的压力，导致比赛的时候确实不够冷静，有一些地方跟队友讲完后就没有再去看了，导致即使两个人看过的做法还是假了。最后两个小时有点盲目自信，观察出了I的一些性质后就一直硬刚，思路也从正解的路上越偏越远，导致更有可能的E和K也没有细想。 至于队伍的问题还是三个人没什么配合，甚至这场有点1+1&lt;2了，很多时候跟队友沟通思路的时候很难让对方理解(或者是我理解不了对方)，最后就是大概是对的这种心态，实际上并没有起到验证的效果，这也使得这场假做法很多(虽然最大原因还是我太爱口胡导致的)。另一点就是三个人没有很好的代码手，唯一一个写代码还行的队友实现能力也算不上强，这点其实去年济南区域赛就有所体现，写代码+假做法+调试占用大量时间导致很多开出来的题都没机会写，感觉暑假还是得多写点题锻炼一下代码能力。除此之外，一个虽然几乎没有影响本场但确实存在的问题就是补题和舒适圈，这场的J的核心思路和我们赛前一天晚上VP的电科校赛的J几乎一模一样，但大家V完看了题解后，因为都不太了解于是似乎也没太当回事，至少对我自己来说，我确实有点太局限于之前OI时期比较熟悉的知识了，像字符串，计算几何以及其它一些套路的题很少去看，只能说还是得多扩充自己的知识面，对于不会的题一定要补。 最后恭喜一下报销n+2亚军成功夺冠，也希望我们明年区域赛不要再像这场一样这么抽象，发挥出实力。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"CS","slug":"CS","permalink":"http://example.com/tags/CS/"},{"name":"游记","slug":"游记","permalink":"http://example.com/tags/%E6%B8%B8%E8%AE%B0/"}],"keywords":[]},{"title":"NWERC2017","slug":"NWERC2017","date":"2024-03-18T14:34:13.000Z","updated":"2024-03-19T10:38:58.471Z","comments":true,"path":"2024/03/18/NWERC2017/","permalink":"http://example.com/2024/03/18/NWERC2017/","excerpt":"","text":"Northwestern European Regional Contest 2017 0.前言 写一下周赛的题解，这场打的感觉不太行。 比赛链接：NWERC 2017 1.题目 A.Ascending Photo 一道挺奇怪的dp 首先把原序列离散化，同时连续的一段相同的数合并为一个数，这些操作显然不影响答案。 我们转换一下问题，我们先把所有数之间都切一刀，考虑最多能选几个位置不切。 注意到对能不切的位置一定是和之间的位置，且对于所有相邻的和，最多只有一个能不切。 直接贪是不行的，例如对，如果我们选择之间不切那么之间就必须切，前后有影响，因此考虑dp(反悔贪心应该也能做，并且个人感觉这个限制并不强，可能有一些神奇的做法也能过，我回头再想想。) 我们设表示只考虑的数时，把第个数放最前面最多能少切几个位置。 枚举顺序即根据的大小，从大到小枚举每个数。 我们根据是否独特，即只有一个位置值为来分类讨论。 同时为了方便叙述，我们设代表所有的位置。 1.独特 如果，我们显然可以将和连在一起。 否则，和在序列中都不相邻，更不可能连在一起。 所以有 2.不独特 注意，这里与上面最大的区别是当独特时，我们只需要考虑是否可以与相连。 而不独特时，我们需要考虑把所有值为的数都放进序列并让在最前面后，序列中最后一个值为的数是否与一个相连。 当，即时，对于，如果有，我们就可以让这个与相连并放在其它值为的数的后面，这样相连的数加(再次提醒和之间最多只有一个相连，所以其它值为的数一定不和相连，这样就是最优。) 当时，因为还有其它值为的数存在，所以我们一定不能让和相连，否则其它值为的数无法插入和中间，这与为最前面的数矛盾，其它情况则与上面相同。 转移方程为 具体实现方案如下： 独特数很简单，随便写一个或改一下非独特的方法就行了。 我们主要考虑非独特时的转移。 注意到，我们每个值为的数在转移时中每一项只有时才会最多相差，那我们不妨记为只考虑的项的最大值，为只考虑的项的最大值，为只考虑的项的次大值。 转移时，如果发现并且则 否则 最后注意一下边界即可。 代码： 1test B.Boss Battle 签到题。 当时，显然答案为。 当时，我们每次选择一个地方炸时可以排除下一时刻BOSS在我们炸的位置，每次炸的位置相连的话，每回合就可以多排除一个位置，那么一共个回合就可以保证炸到BOSS。 代码： 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n=0; scanf(\"%d\",&amp;n); if(n&lt;=3){printf(\"1\");return 0;} printf(\"%d\",n-2); return 0;} D.Dunglish 模拟+一点点数学，读懂题意就能写。 显然，对原序列第i个单词，设其总翻译数为，正确翻译数为 那么总翻译方案数为，正确翻译方案数为，错误翻译方案数即两个相减。 用map就可以存下 代码实现的比较乱，回头有时间改改。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;string s[25],x,y,z;map&lt;string,ll&gt; M1,M2,ppd;map&lt;string,string&gt; M;int main(){ int n=0,m=0,pd=0;ll ans1=1,ans2=0,zc=1; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s[i]; } scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;i++) { cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; if(z[0]=='c') { M1[x]++; } else { M2[x]++; ppd[x]=1; } M[x]=y; } for(int i=1;i&lt;=n;i++) { ans1=ans1*M1[s[i]]; zc=zc*(M1[s[i]]+M2[s[i]]); } ans2=zc-ans1; if(zc==1) { for(int i=1;i&lt;=n;i++) { cout&lt;&lt;M[s[i]]&lt;&lt;\" \"; if(ppd[s[i]]==1){pd=1;} } putchar('\\n'); if(pd) { printf(\"incorrect\\n\"); } else { printf(\"correct\\n\"); } } else { printf(\"%lld correct\\n\",ans1); printf(\"%lld incorrect\\n\",ans2); } return 0;} F.Factor-Free Tree 回头补() 代码： 1test G.Glyph Recognition 计算几何。 直接按题意枚举即可，最小边长可以二分查找，也可以手推，但手推估计比较痛苦。 个人感觉不太好实现，回头看看别人怎么写得。 代码： 1test I.Installing Apps dp+贪心 首先转换成堆箱子的问题(每个箱子有自重和最大承重，问能否从上到下堆在一起)。 对下载大小为，储存大小为的软件，等价于自重为，最大承重为的箱子。 直接由箱子的结论得到，如果存在合法方案，我们一定可以把方案中的箱子按自重加最大承重从小到大的排序顺序从上往下堆。 再看原问题，即按从小到大排序，然后按序找安装哪些软件。 显然，我们可以用01背包解决。 注意，这里我们的状态可以不设成表示前i个软件占大小为j的最大个数，而是，表示前i个软件安装j个的最小内存，这样更好实现并且时间复杂度更低。 最后给一下箱子结论的证明： 我们设表示自重，表示承重，第个箱子为最上面的，第个箱子为最下面的。 假设一种合法方案中，存在，有，那么我们将和交换位置。 则交换后合法的条件为 即： 由原方案合法得： 所以： 该结论得证。(还有个小结论是如果存在合法方案，这样排序可以使最小的承重减负重的值最大) 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;struct node{ int d;int s;int nu; bool operator &lt; (const node &amp;x)const { return (s-d)&lt;x.s-x.d; }};node a[505];int f[505][505],pre[505][505];int Ans[505],cnt;int main(){ int n=0,c=0,ans=0,z=0; scanf(\"%d%d\",&amp;n,&amp;c); for(int i=1;i&lt;=n;i++) { scanf(\"%d%d\",&amp;a[i].d,&amp;a[i].s); a[i].nu=i; } sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { f[i][j]=1e9; } } f[0][0]=0; for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;i;j++) { if(f[i][j]&gt;f[i-1][j]) { f[i][j]=f[i-1][j]; pre[i][j]=0; } if(f[i][j+1]&gt;f[i-1][j]+a[i].s&amp;&amp;c-f[i-1][j]&gt;=a[i].d) { f[i][j+1]=f[i-1][j]+a[i].s; pre[i][j+1]=i; } } } for(int j=n;j&gt;=0;j--) { if(f[n][j]&lt;=c) { z=j; break; } } printf(\"%d\\n\",z); while(z) { if(!pre[n][z]) { n--; } else { cnt++;Ans[cnt]=a[n].nu; z--;n--; } } for(int i=cnt;i;i--) { printf(\"%d \",Ans[i]); } return 0;} J.Juggling Troupe 最有意思的一道。 我们先考虑只有个的情况，假设所在的位置为，左边最近的的位置为(如果没有则)，右边最近的的位置为(如果没有则)。 如果写个暴力观察一下就会发现转移过程很有规律，结果为变成，变成，变成，如果，那么变成 PS:如果或实际上就是球扔到台下，但我们可以认为球仍在或，并且这两个位置的球不会移动。 我们可以由不变量给出一个不太严谨的证明： 首先，设表示第个位置球的数量， 那么易证，和在整个过程中是守恒的。 我们只考虑L到R的区域(这一步其实不严谨，可以证明一定只有到间会发生转移，但有点麻烦) 既然如此，只有一个的情况下，最后，原本的个数为，则由守恒得到最后应该只有个，其余位置都为 那么设为的位置为，由守恒得： 然后就是本题重点，如何证明球转移的顺序是无关的。 这个结论还是挺好猜的，但不一定敢写。 证明如下： 我们认为第个位置向两边扔球为对进行一次操作，那我们会有一个初始的可操作集合。 注意到对操作后，只会让的可操作次数减，两边位置的可操作次数可能加(或者说加，其实就是) 那么不论我们的操作的顺序如何，每个数被操作的次数其实是不会因此改变的，结果自然也相同。 所以，我们只需对每个单独考虑就行。 实现就用set维护的位置和每个对应的和，注意一个细节就是如果的位置是另一个，我们应该把它改成而不是 PS：这道题证明顺序无关的方法感觉挺容易推广到其它问题上的。 大概可以这样表述： 对某一元素操作不会使其它元素的操作次数减少，只会按一个关于该操作为对该元素第几次操作的规则影响其它元素的操作次数(只可能使其它元素操作次数增加，不会造成其它影响)，那么操作顺序无关。 这里贴一下相关的几道题。 Codeforces Global Round 10 F.Omkar and Landslide Hot Dog Proliferation (Large) 还有一个叫《十步万度》的游戏，里面操作的可交换性也可以这么证。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define It set&lt;int&gt;::iteratorusing namespace std;const int Maxn=1e6+5;char c[Maxn];int a[Maxn];set&lt;int&gt; s;int main(){ int n=0,L=0,R=0,x=0;It itl,itr; scanf(\"%s\",c+1); n=strlen(c+1); s.insert(0);s.insert(n+1); for(int i=1;i&lt;=n;i++) { a[i]=c[i]-'0'; if(!a[i]){s.insert(i);} } for(int i=1;i&lt;=n;i++) { if(a[i]!=2){continue;} itl=s.lower_bound(i); itr=itl;itl--;R=*itr;L=*itl; if(L){a[L]=1;s.erase(itl);} if(R!=n+1){a[R]=1;s.erase(itr);} a[i]=1;x=L+R-i;a[x]--; if(!a[x]){s.insert(x);} } for(int i=1;i&lt;=n;i++) { printf(\"%d\",a[i]); } return 0;}","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"CS","slug":"CS","permalink":"http://example.com/tags/CS/"},{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"}],"keywords":[]},{"title":"Matula","slug":"Matula","date":"2024-03-12T16:19:27.000Z","updated":"2024-03-12T16:19:27.722Z","comments":true,"path":"2024/03/13/Matula/","permalink":"http://example.com/2024/03/13/Matula/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"更新计划","slug":"plan","date":"2024-03-02T04:15:25.000Z","updated":"2024-07-14T11:16:58.392Z","comments":true,"path":"2024/03/02/plan/","permalink":"http://example.com/2024/03/02/plan/","excerpt":"","text":"更新计划 暂定的该博客的更新计划。 1.评论系统 目前在考虑用Twikoo还是Waline，不清楚Twikoo的安全性怎么样。 (你真觉得这个博客会有人看吗) 2.置顶显示 把置顶的tag变成自动添加的。 3.个性化域名 如题。 4.彩蛋 虽然这个博客大概没什么人看就是了。","categories":[],"tags":[{"name":"置顶","slug":"置顶","permalink":"http://example.com/tags/%E7%BD%AE%E9%A1%B6/"}],"keywords":[]},{"title":"GEB读书笔记","slug":"GEB","date":"2024-03-01T13:52:16.000Z","updated":"2024-03-01T13:57:17.755Z","comments":true,"path":"2024/03/01/GEB/","permalink":"http://example.com/2024/03/01/GEB/","excerpt":"","text":"开个大坑，准备读GEB的英文原著，这篇博客用来记录读书笔记和想法，先占个位。 希望半年内能读完吧。","categories":[],"tags":[{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}],"keywords":[]},{"title":"射影几何0","slug":"projective-geometry0","date":"2024-02-28T06:21:40.000Z","updated":"2024-03-02T08:21:31.094Z","comments":true,"path":"2024/02/28/projective-geometry0/","permalink":"http://example.com/2024/02/28/projective-geometry0/","excerpt":"","text":"准备有时间学一下射影几何，先占个坑。","categories":[],"tags":[],"keywords":[]},{"title":"浅谈约瑟夫环问题","slug":"josephus-problem","date":"2024-02-25T09:23:36.000Z","updated":"2024-03-03T06:51:54.245Z","comments":true,"path":"2024/02/25/josephus-problem/","permalink":"http://example.com/2024/02/25/josephus-problem/","excerpt":"","text":"浅谈约瑟夫环问题 Update:寄，写完了突然发现和oi-wiki上的几乎一模一样，脑回路神奇地重合了。 不过一些地方理解方式有些区别，只能说还是有点意义的。 0.前言 近日洛谷上看到了这道题P8671 [蓝桥杯 2018 国 AC] 约瑟夫环，发现自己对约瑟夫环的一些写法不太了解，所以记录一下。 1.问题叙述 本文讨论的约瑟夫环问题表述如下： 个人，从开始报数，数到的人淘汰，然后重新从报数，问最后一人的编号，为了讲述方便，我们规定编号从开始。 2.通用解法 2.1 暴力枚举 我们用链表储存现有的人，然后暴力枚举。这样做删除的复杂度为，寻找下一个人的复杂度为 (还有一种实现，对每个元素记录它之前和之后第个元素的编号，每删除一个元素后，对它前k个元素进行修改，删除的复杂度，但个人觉得实现比较复杂) 时间复杂度： 2.2 数据结构优化 注意到2.1的瓶颈在于寻找下一个被淘汰的人，我们考虑用数据结构优化。 我们改用数组存储每个人是否被淘汰，然后用线段树二分在的时间内寻找下一个元素。 时间复杂度： 另外，我们也可以用跳表等维护。 2.3 递推 这算是一个重点了，我们设表示个人，数到淘汰的前提下，最后剩下的人的编号，且编号从开始。 显然，我们考虑从个人开始添加人会使最后的幸存者的编号发生什么变化。 即已知，求 显然，个人开始游戏后，第一个被淘汰的人的编号为，我们会从编号的人开始报数，且此时只有个人，我们把这个人当作新的，那答案显然为，再将新编号换为原本的编号，我们就有 线性递推地做即可。 时间复杂度： 2.4 递推优化 观察2.3的式子，我们实际上没有必要在每次加上后都进行取模。只有当时，我们才需要减去，并且有 考虑只在需要取模时转移，设当前已求出人数为的情况，下一个需要取模的人数为，则 即 即 算出后，可以由 得到，然后将作为新的 按如上方式转移，直到对于当前求出的，然后得到 从而求出答案，注意时需要特判。 时间复杂度：的增长率大约为，因此使大于等于的时间复杂度约为 我们设 则 画图后观察到收敛很快，因此我们可以将近似为一条直线，斜率为在趋于正无穷时的极限，易得 由上述得， 时间复杂度为 当时上式较为准确，与大小相近时会有较大偏差。 3.一些其它结论 3.1 时的答案 当时，我们可以通过另一种方法得到答案。 假设，我们易得(每次所有人数过一遍后，剩下的人数仍为的幂) 所以当总人数为2的幂时，从谁开始，则谁为最后剩下的人。 那考虑一般情况 当淘汰了个人时，我们有 所以此时我们会从编号为的人开始，且只剩下个人，最后剩下的编号即为 所以对，有 3.2 对时答案的探索 4.推广问题 约瑟夫问题还可以进行一些推广。 比如每次淘汰数最后个数的人，求最后剩下的个人的编号。 等之后我有想法了再来补充。","categories":[{"name":"CS","slug":"CS","permalink":"http://example.com/categories/CS/"},{"name":"ACM","slug":"CS/ACM","permalink":"http://example.com/categories/CS/ACM/"},{"name":"数学","slug":"CS/ACM/数学","permalink":"http://example.com/categories/CS/ACM/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"CS","slug":"CS","permalink":"http://example.com/tags/CS/"},{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}],"keywords":[{"name":"CS","slug":"CS","permalink":"http://example.com/categories/CS/"},{"name":"ACM","slug":"CS/ACM","permalink":"http://example.com/categories/CS/ACM/"},{"name":"数学","slug":"CS/ACM/数学","permalink":"http://example.com/categories/CS/ACM/%E6%95%B0%E5%AD%A6/"}]},{"title":"CF926","slug":"CF926","date":"2024-02-18T10:53:10.000Z","updated":"2024-07-14T11:06:42.546Z","comments":true,"path":"2024/02/18/CF926/","permalink":"http://example.com/2024/02/18/CF926/","excerpt":"","text":"CF926 div2 比赛链接：Codeforces Round 926 (Div. 2) 有点水，但确实是最近CF打的最好的一场了，各种降智操作(这不还是打得不行吗)的前提下，赛时过了5题，赛后5min把最后一道题调好了(其实如果E和F不降智的话感觉能提前AK下班) A.Sasha and the Beautiful Array 题目链接：Sasha and the Beautiful Array 显然全加起来为，所以答案为序列中最大值减最小值。 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int T=0,n=0,x=0,Ma=0,Mi=0; scanf(\"%d\",&amp;T); while(T--) { Ma=0;Mi=1e9+7; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;x); Ma=max(Ma,x); Mi=min(Mi,x); } printf(\"%d\\n\",Ma-Mi); } return 0;} B.Sasha and the Drawing 题目链接：Sasha and the Drawing 思维题，容易想到一个点位于两条对角线上。 考虑如何表示对角线，可以发现一种可以用其上点的行和列的和表示，另一种可以用其上点的行和列的差表示，分别设其为 则点在上 尝试构造，发现前个点可以放在上，每个点对应两条对角线。第个到第个点可以放在上，对应两个对角线，最后两个点放在上，分别只能对应一个对角线。 容易证明没有更优的方案，易得只能由对应，且两个点都对应，所以不存在更优方案。 因此答案为 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int T=0,n=0,k=0,ans=0; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d%d\",&amp;n,&amp;k); ans=k/2; if(k==4*n-2||k%2) { ans++; } printf(\"%d\\n\",ans); } return 0;} C.Sasha and the Casino 题目链接：Sasha and the Casino 感觉全场最好的题了，就是爆long long有点坑人。 设我们输了场后，再次赌博投入的钱为，的前缀和为 如果我们在某一场获胜，那么我们赢的钱必须大于总共投入的钱，即： 如果我们连输x场后，则我们一定会把剩的所有钱都投入下一场，那么我们必须保证我们至少还剩钱并且赢后赚的钱大于我们初始的钱，即： 因此我们可以对于每个，我们可以求出，如果并且则输出YES，否则输出NO。 注意当较小时，会爆long long，所以当时就直接输出NO。 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int main(){ int T=0;ll s=0,x=0,y=0,a=0,k=0; scanf(\"%d\",&amp;T); while(T--) { s=0; scanf(\"%lld%lld%lld\",&amp;k,&amp;x,&amp;a); for(int i=1;i&lt;=x;i++) { y=s/(k-1ll)+1ll; s=s+y; if(s&gt;=a) { break; } } if(s&gt;=a||(a-s)*k&lt;=a) { printf(\"NO\\n\"); } else { printf(\"YES\\n\"); } } return 0;} D.Sasha and a Walk in the City 题目链接：Sasha and a Walk in the City 一眼树形dp，注意到对一个点，它的一棵子树中如果有两个染色点且其中一个为另一个的祖先，那么其余子树中都不能有染色点，考虑据此设状态。 如果一棵合法的树中至少存在一个染色点为另一染色点祖先，记其具有性质A。 如果一棵合法的树中存在染色点但染色点均不为其它染色点祖先，记其具有性质B。 设表示以为根节点的树具有性质A的方案数，表示以为根节点的树具有性质B的方案数。 先考虑，有两种情况，染色且的子树中都没有染色点，不染色且至少一棵子树具有性质B。 再考虑，有两种情况，不染色且有且仅有一棵子树具有性质A，其它子树均无染色点，染色且有且仅有一棵子树具有性质B，其它子树均无染色点。 转移方程如下： 为儿子为儿子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int P=998244353;int cnt,u[300005],Next[600005],To[600005];int f[300005],g[300005];void adde(int x,int y){ cnt++;Next[cnt]=u[x];u[x]=cnt;To[cnt]=y; cnt++;Next[cnt]=u[y];u[y]=cnt;To[cnt]=x; return;}void dfs(int x,int fa){ int zc=0;g[x]=1; for(int i=u[x];i;i=Next[i]) { zc=To[i]; if(zc==fa){continue;} dfs(zc,x); f[x]=((f[x]+f[zc])%P+g[zc])%P; g[x]=1ll*g[x]*(g[zc]+1ll)%P; } return;}int main(){ int T=0,n=0,x=0,y=0,ans=0; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d\",&amp;n); for(int i=1;i&lt;n;i++) { scanf(\"%d%d\",&amp;x,&amp;y); adde(x,y); } dfs(1,1); ans=((f[1]+g[1])%P+1ll)%P; printf(\"%d\\n\",ans); cnt=0; for(int i=1;i&lt;=n;i++) { u[i]=0;f[i]=0;g[i]=0; } } return 0;} E.Sasha and the Happy Tree Cutting 题目链接：Sasha and the Happy Tree Cutting Update：所以根本不用写树剖，求Lca直接暴力求顺便更新就行了，降智延续到了赛后，悲。 降智的顶峰。 比赛的时候树剖板子找不到，又重写了一遍，所以根本不用啊。 外加从头到尾看错题，以为要染色的是点，结束了才发现要染色的是边，改了一下就过了。 首先读题，发现给了一个的限制，所以猜测std复杂度与有关，应该是要枚举每一种可能的已经满足要求的情况，因此一种自然的想法如下： 考虑状压dp，设表示满足集合中的点对所需的最小边数，表示边可以满足的点对集合。 显然可能有贡献的边都在点对的简单路径上，因此我们暴力跳父亲找lca，并更新路径上边可以满足的点对集合。时间复杂度： 我们可以由已知状态更新新状态，即： 时间复杂度：，肯定是过不了的。 考虑继续优化，注意到我们实际上可以先求出虚树，最后选择的边一定可以对应到虚树上，而虚树上边的数量是的，再按上述步骤做，就可以得到答案。 时间复杂度： 当然，为了实现方便，我们也可以不建虚树，考虑只保留无法被替代的边，即对任意边，如果有边满足，那么删去边，保留，可以证明这样剩下的边和在虚树上等价(应该吧，实际上我没证)，数量也是的。 时间复杂度： 正常版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;int lca[25],a[25],b[25];int f[200005];int N,nu[1005];int g[2000005];int cnt,u[100005],Next[200005],To[200005];int fa[100005];int d[100005],ff[100005];void adde(int x,int y){ cnt++;Next[cnt]=u[x];u[x]=cnt;To[cnt]=y; cnt++;Next[cnt]=u[y];u[y]=cnt;To[cnt]=x; return;}void dfs(int x,int D){ int zc=0;d[x]=D; for(int i=u[x];i;i=Next[i]) { zc=To[i]; if(zc==fa[x]){ff[x]=i;continue;} fa[zc]=x;dfs(zc,D+1); } return;}void Lca(int x,int y,int z){ if(d[x]&lt;d[y]){swap(x,y);} while(d[x]&gt;d[y]) { f[ff[x]]=f[ff[x]]|(1&lt;&lt;z); x=fa[x]; } while(x!=y) { f[ff[x]]=f[ff[x]]|(1&lt;&lt;z); f[ff[y]]=f[ff[y]]|(1&lt;&lt;z); x=fa[x];y=fa[y]; } return;}void Add(int x){ int z=0; for(int i=1;i&lt;=N;i++) { z=nu[i]; if((f[z]|f[x])==f[z]) { return; } if((f[z]|f[x])==f[x]) { nu[i]=x; return; } } N++;nu[N]=x; return;}void Solve(int x){ int zc=0; for(int i=u[x];i;i=Next[i]) { zc=To[i]; if(zc==fa[x]){Add(i);continue;} Solve(zc); } return;}int main(){ int T=0,n=0,k=0,x=0,y=0,z=0,Lim=0; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d\",&amp;n); for(int i=1;i&lt;n;i++) { scanf(\"%d%d\",&amp;x,&amp;y); adde(x,y); } dfs(1,1); scanf(\"%d\",&amp;k); for(int i=0;i&lt;k;i++) { scanf(\"%d%d\",&amp;a[i],&amp;b[i]); Lca(a[i],b[i],i); } Solve(1);Lim=(1&lt;&lt;k)-1; for(int i=1;i&lt;=Lim;i++){g[i]=1e6;} for(int i=0;i&lt;=Lim;i++) { for(int j=1;j&lt;=N;j++) { z=i|f[nu[j]]; g[z]=min(g[z],g[i]+1); } } printf(\"%d\\n\",g[Lim]); for(int i=1;i&lt;=cnt;i++) { f[i]=0; } N=0;cnt=0; for(int i=1;i&lt;=n;i++) { ff[i]=0;u[i]=0;d[i]=0;fa[i]=0; } } return 0;} 一个傻子不知道为什么写了树剖版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;bits/stdc++.h&gt;using namespace std;int lca[25],a[25],b[25];int f[200005];int N,nu[1005];int g[2000005];int cnt,u[100005],Next[200005],To[200005];int Size[100005],Son[100005],Tp[100005],fa[100005];int d[100005],ff[100005];void adde(int x,int y){ cnt++;Next[cnt]=u[x];u[x]=cnt;To[cnt]=y; cnt++;Next[cnt]=u[y];u[y]=cnt;To[cnt]=x; return;}void dfs1(int x,int D){ int zc=0;d[x]=D;Size[x]=1; for(int i=u[x];i;i=Next[i]) { zc=To[i]; if(zc==fa[x]){ff[x]=i;continue;} fa[zc]=x; dfs1(zc,D+1);Size[x]=Size[x]+Size[zc]; if(Size[x]&gt;Size[Son[x]]){Son[x]=zc;} } return;}void dfs2(int x,int Top){ int zc=0; Tp[x]=Top; if(Son[x]){dfs2(Son[x],Top);} for(int i=u[x];i;i=Next[i]) { zc=To[i]; if(zc==Son[x]||zc==fa[x]){continue;} dfs2(zc,zc); } return;}int Lca(int x,int y){ while(Tp[x]!=Tp[y]) { if(d[Tp[x]]&lt;d[Tp[y]]) { swap(x,y); } x=fa[Tp[x]]; } if(d[x]&gt;d[y]){swap(x,y);} return x;}void Ins(int x,int Now){ while(x!=lca[Now]) { f[ff[x]]=f[ff[x]]|(1&lt;&lt;Now); x=fa[x]; } return;}void Add(int x){ int z=0; for(int i=1;i&lt;=N;i++) { z=nu[i]; if((f[z]|f[x])==f[z]) { return; } if((f[z]|f[x])==f[x]) { nu[i]=x; return; } } N++;nu[N]=x; return;}void dfs3(int x){ int zc=0; for(int i=u[x];i;i=Next[i]) { zc=To[i]; if(zc==fa[x]){Add(i);continue;} dfs3(zc); } return;}int main(){ int T=0,n=0,k=0,x=0,y=0,z=0,Lim=0; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d\",&amp;n); for(int i=1;i&lt;n;i++) { scanf(\"%d%d\",&amp;x,&amp;y); adde(x,y); } dfs1(1,1);dfs2(1,1); scanf(\"%d\",&amp;k); for(int i=0;i&lt;k;i++) { scanf(\"%d%d\",&amp;a[i],&amp;b[i]); lca[i]=Lca(a[i],b[i]); Ins(a[i],i);Ins(b[i],i); } dfs3(1);Lim=(1&lt;&lt;k)-1; for(int i=1;i&lt;=Lim;i++){g[i]=1e6;} for(int i=0;i&lt;=Lim;i++) { for(int j=1;j&lt;=N;j++) { z=i|f[nu[j]]; g[z]=min(g[z],g[i]+1); } } printf(\"%d\\n\",g[Lim]); for(int i=1;i&lt;=cnt;i++) { f[i]=0; } N=0;cnt=0; for(int i=1;i&lt;=n;i++) { ff[i]=0;u[i]=0;Son[i]=0;Size[i]=0; d[i]=0;fa[i]=0; } } return 0;} F.Sasha and the Wedding Binary Search Tree 题目链接：Sasha and the Wedding Binary Search Tree 降智的开始，最开始搞了一个不太可维护的有点类似Splay的做法，后来发现完全没必要。 顺便吐槽一下F有点过于简单了，评价为E &gt; F。 首先给出两个公式： (I).个点，值域连续且大小为，每个点单调不降，且最后一个点为最大值的方案个数为 (II).个点，值域连续且大小为，每个点单调不降，且最后一个点任意的方案个数为 证明如下： (I)可以转化成一个行列的格子，为起点，为终点，只能向右或向下，从起点走到终点的方案数，对于每种方案，如果第行走到的最右边的列为第列，则第个数为，显然这样得到的序列满足条件，且方案与序列一一对应，QED. (II)则是(I)的推论。 再看原问题，题目中定义的二叉搜索树显然就可以对应到一个单调不降的序列，且某些位置已知。两个已知值中间或从开始到第一个已知值对应(I)，最后一个已知值到终点对应(II)，直接做就行。 具体如下：假如前一个已知值为，后一个已知值为,这一段长度(注意起点是不是)，值域大小，方案数为，从已知值到终点基本同理。 一个细节是计算组合数时不能预处理阶乘，因为可能很大，要按照的写法写，因为所有的之和小于等于。 时间复杂度： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int P=998244353;int inv[500005],ji[500005];int li[500005],ri[500005],vi[500005];int cnt,nu[500005];int len,a[500005],v[500005];void _Init(){ int N=5e5; ji[0]=1; inv[1]=1;ji[1]=1; for(int i=2;i&lt;=N;i++) { inv[i]=P-1ll*P/i*inv[P%i]%P; ji[i]=1ll*ji[i-1]*inv[i]%P; } return;}int nCr(int x,int y){ if(y&gt;x){return 0;} int ans=1; for(int i=1;i&lt;=y;i++) { ans=1ll*ans*(x+i-y)%P*inv[i]%P; } return ans;}void dfs(int x){ if(li[x]!=-1){dfs(li[x]);} cnt++;nu[x]=cnt; if(vi[x]!=-1) { len++;a[len]=cnt;v[len]=vi[x]; } if(ri[x]!=-1){dfs(ri[x]);} return;}int main(){ int T=0,n=0,C=0,ans=0,x=0,y=0; _Init();v[0]=1; scanf(\"%d\",&amp;T); while(T--) { ans=1;len=0;cnt=0; scanf(\"%d%d\",&amp;n,&amp;C); for(int i=1;i&lt;=n;i++) { scanf(\"%d%d%d\",&amp;li[i],&amp;ri[i],&amp;vi[i]); } dfs(1); for(int i=1;i&lt;=len;i++) { x=a[i]-a[i-1];y=v[i]-v[i-1]+1; ans=1ll*ans*nCr(x+y-2,x-1)%P; } x=n-a[len];y=C-v[len]+1; ans=1ll*ans*nCr(x+y-1,x)%P; printf(\"%d\\n\",ans); } return 0;}","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"CS","slug":"CS","permalink":"http://example.com/tags/CS/"},{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"}],"keywords":[]},{"title":"CF924","slug":"CF924","date":"2024-02-18T10:52:49.000Z","updated":"2024-07-14T11:23:32.102Z","comments":true,"path":"2024/02/18/CF924/","permalink":"http://example.com/2024/02/18/CF924/","excerpt":"","text":"CF924 Div2 比赛链接：Codeforces Round 924 (Div. 2) 新年补的第一场。 A.Rectangle Cutting 题目链接：Rectangle Cutting 签到，显然至少一边为偶数且不为另一边的两倍。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int T=0,a=0,b=0; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d%d\",&amp;a,&amp;b); if(!(a%2)&amp;&amp;b!=(a&gt;&gt;1)) { printf(\"Yes\\n\"); } else if(!(b%2)&amp;&amp;a!=(b&gt;&gt;1)) { printf(\"Yes\\n\"); } else { printf(\"No\\n\"); } } return 0;} B.Equalize 题目链接：Equalize 容易想到相同的数操作后不同，最多只有一个有贡献。假设操作后最多的数为，那么有贡献的数的区间为，显然可以用双指针维护。 时间复杂度： 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int a[200005];int main(){ int T=0,n=0,N=0,l=0,r=0,ans=0; scanf(\"%d\",&amp;T); while(T--) { ans=0; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); } sort(a+1,a+n+1); N=unique(a+1,a+n+1)-(a+1); l=1;r=1; for(;l&lt;=n;l++) { while(a[r+1]&lt;=a[l]+n-1&amp;&amp;r&lt;N) { r++; } ans=max(ans,r-l+1); } printf(\"%d\\n\",ans); } return 0;} C.Physical Education Lesson 题目链接：Physical Education Lesson 有点麻烦，首先我们按下图分为上升段与下降段。 image1 假设在第个上升段上，有，即 合法的个数为的大于的偶因子个数。 同理，假设在第个下降段上，有，即 合法的个数为的大于等于的偶因子个数。 将上述两种的个数相加即为答案。 时间复杂度： 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int T=0,n=0,x=0,N=0,Lim=0,ans=0,z=0; scanf(\"%d\",&amp;T); while(T--) { ans=0; scanf(\"%d%d\",&amp;n,&amp;x); N=n-x;Lim=sqrt(N); for(int i=1;i&lt;=Lim;i++) { if(N%i){continue;} z=i;if(!(z%2)&amp;&amp;z&gt;2*x-2){ans++;} if(i*i==N){continue;} z=N/i;if(!(z%2)&amp;&amp;z&gt;2*x-2){ans++;} } if(x!=1) { N=n+x-2;Lim=sqrt(N); for(int i=1;i&lt;=Lim;i++) { if(N%i){continue;} z=i;if(!(z%2)&amp;&amp;z&gt;=2*x-2){ans++;} if(i*i==N){continue;} z=N/i;if(!(z%2)&amp;&amp;z&gt;=2*x-2){ans++;} } } printf(\"%d\\n\",ans); } return 0;} D.Lonely Mountain Dungeons 题目链接：Lonely Mountain Dungeons 有点诈骗，猜了半天是不是单峰，后来发现不是并且无所谓。 考虑单个种族，总人数为，设共队，每队人数为，则战力值为，显然人分得越平均越好。 那么设，有队人数为，队人数为，显然能计算贡献。 又注意到当时，贡献不会变化，于是考虑先根据排序后，枚举，且只改变的种族的贡献，那么转移次数为 时间复杂度： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll c[200005];ll Calc(ll x,ll y){ if(!y){return 0;} ll ans=0,z1=0,z2=0; z1=x/y;z2=x%y; ans=(x*x-z2*(z1+1ll)*(z1+1ll)-(y-z2)*z1*z1)/2ll; return ans;}int main(){ int T=0,n=0,Now=0;ll k=0,Lim=0,b=0,x=0,ans=0,z=0; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d%lld%lld\",&amp;n,&amp;b,&amp;x); for(int i=1;i&lt;=n;i++) { scanf(\"%lld\",&amp;c[i]); Lim=max(Lim,c[i]); } sort(c+1,c+n+1);Now=1;z=x; for(k=1;k&lt;=Lim;k++) { while(k&gt;c[Now]){Now++;} for(int i=Now;i&lt;=n;i++) { z=z-Calc(c[i],k-1)*b+Calc(c[i],k)*b; } z=z-x; ans=max(ans,z); } printf(\"%lld\\n\",ans); ans=0;Now=0;Lim=0;z=0; } return 0;} E.Modular Sequence 题目链接：Modular Sequence 乐，只有补题时才能1A过五题，不过这场div2好像确实有点简单() 容易发现，对于模序列中的任意元素都能表示为，且或。 那么设，显然才可能有解。 设，则要求 注意到我们可以把序列分成一个个连续段，且每个连续段的大小不超过，我们不妨考虑利用这个性质做dp，设表示序列和为时所需最短序列长度，同时枚举最后一个连续段的长度，有如下转移方程： 初始状态为： 时间复杂度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int Inf=1e6;int f[200005],Ans[200005],pre[200005];int main(){ int T=0,n=0,cnt=0;ll Now=0,m=0,x=0,y=0,s=0,z=0; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d%lld%lld%lld\",&amp;n,&amp;x,&amp;y,&amp;s); z=x%y;m=s-n*z; if(m%y||m&lt;0){printf(\"No\\n\");continue;} m=m/y;x=x/y;cnt=1;Now=x; for(int i=0;i&lt;=m;i++){f[i]=Inf;} while(Now&lt;=m) { f[Now]=cnt;pre[Now]=cnt; Now=Now+x+cnt;cnt++; } for(int i=1;i&lt;=m;i++) { if(f[i]!=Inf){continue;} for(int j=1;;j++) { Now=i-j*(j-1)/2; if(Now&lt;0){break;} if(f[Now]+j&lt;f[i]) { f[i]=f[Now]+j; pre[i]=j; } } } if(f[m]&lt;=n) { Now=m;cnt=0; while(1) { for(int i=1;i&lt;=pre[Now];i++) { cnt++;Ans[cnt]=pre[Now]-i; } if(f[Now]==pre[Now]) { for(int i=1;i&lt;=pre[Now];i++) { Ans[cnt-i+1]=Ans[cnt-i+1]+x; } break; } Now=Now-pre[Now]*(pre[Now]-1)/2; } printf(\"Yes\\n\"); for(int i=cnt;i;i--) { printf(\"%d \",Ans[i]*y+z); } for(int i=cnt+1;i&lt;=n;i++) { printf(\"%d \",z); } putchar('\\n'); } else { printf(\"No\\n\"); } } return 0;} F.Digital Patterns 题目链接：Digital Patterns 1","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"CS","slug":"CS","permalink":"http://example.com/tags/CS/"},{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"}],"keywords":[]}]}